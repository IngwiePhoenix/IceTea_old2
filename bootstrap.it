SettingsContainer = extends Object {
    __construct: function() {
        @stores = arguments;
    },
    __get: function(key) {
        for(var _,store in @stores) {
            if(key in store) {
                return store[key];
            }
        }
        throw "Unable to find setting ${key} in specified containers.";
    },
    __isset: function(key) {
        for(var _,store in @stores) {
            if(key in store) {
                return true;
            }
        }
        return false;
    },
    __getCombined: function(key) {
        var start = null;
        for(var _,store in @stores) {
            if(key in store) {
                if(typeOf(start) == "null") {
                    start = store[key];
                } else {
                    var v = store[key];
                    start += v;
                }
            }
        }
        return start;
    }
}

NativeStep = extends Object {
    // Native objects always have .o or .obj. So, we can groundwire this.
    pattern: (sys.type=='unix'
        ? '%o/.%t/%b.o'
        : '%o/.%t/%b.obj'
    ),

    // All that this configure() function does, is to look for the compiler.
    configure: function() {
        detect.compiler(@name);
    },

    // Build
    build: function() {
        // Getting the key that we use to acces Detector stuff.
        var key = detect.kind2key(@backend.name);

        // The settings we'll work off.
        var settings = SettingsContainer(
            "native" in @target.settings ? @target.settings.native : {},
            key in @target.settings ? @target.settings[key] : {}
        );

        // We will put the entire bulk of the command in here and join it up later.
        var commandLine = [];
        var compiler = detect.compiler(@backend.name);
        commandLine.push(compiler);

        // FIXME: React on Windows or cl.exe, when being in Wine.
        // Turn on C++ standard exceptions.
        if(sys.type == "windows" || compiler == "cl") {
            commandLine.push("/nologo");
            if(!("WindowsExceptions" in settings)) {
                commandLine.push("/EHsc");
            } else {
                settings.WindowsExceptions
                    && commandLine.push("/EHsc");
            }
        }

        if("warningsAsErrors" in settings) {
            commandLine.push((
                sys.type == "unix"
                ? "-Werror" // GCC/Clang
                : "/WX"     // MSVC
            ));
        }

        // Only for windows
        if(sys.type == "windows" && "warningLevel" in settings) {
            commandLine.push("/W"..settings.warningLevel);
        }

        var warnings = settings.__getCombined("warnings");
        if(warnings != null) {
            for(var _,warn in warnings) {
                commandLine.push((
                    sys.type == "unix"
                    ? "-W"  // GCC-Style warnings - enables it.
                    : "/w"  // MSVC-Style warnings. Turns on this very warning, on this level.
                )..warn);
            }
        }

        // Optimization?
        if("optimization" in settings) {
            switch(settings.optimization) {
                case "none":
                    commandLine.push((sys.type == "unix" ? "-O0" : ""));
                break;

                case "small":
                    commandLine.push((sys.type == "unix" ? "-O1" : "/O1"));
                break;

                case "medium":
                    commandLine.push((sys.type == "unix" ? "-O2" : "/O2"));
                break;

                case "max":
                    commandLine.push((sys.type == "unix" ? "-O3" : "/O3"));
                break;

                case "size":
                    commandLine.push((sys.type == "unix" ? "-Os" : "/Os"));
                break;

                default:
                    // In case the user is being randomly custom.
                    commandLine.push(settings.optimization);
                break;
            }
        }

        var includeDirs = settings.__getCombined("includeDirs");
        for(var _,dir in includeDirs) {
            commandLine.push((
                sys.type == "unix"
                ? "-I"   // GCC/Clang
                : "/I"   // MSVC
            )..dir);
        }

        var defines = settings.__getCombined("defines");
        for(var _,def in defines) {
            commandLine.push((
                sys.type == "unix"
                ? "-D"
                : "/D"
            )..def);
        }

        var extraFlags = settings.__getCombined("flags");
        for(var _,flag in extraFlags) {
            commandLine.push(flag);
        }

        if(DEBUG) {
            commandLine.push((
                sys.type == "unix"
                ? "-g"
                : "/Zi"
            ));
        }

        // Now that all the flags are set, let us write the actual how-to-compile.
        var compileFlag = (sys.type == "unix" ? "-c" : "/c");
        var outFlag = (sys.type == 'unix' ? '-o' : '/Fo');
        commandLine.push(compileFlag);
        commandLine.push(@in);
        commandLine.push([
            outFlag, @out
        ].join(""));

        // Create the output folder for the object.
        var outDir = pfs.dirname(@out);
        debug "Mkdir: ${outDir}"
        pfs.mkdir(outDir);

        // FIXME: Make and use AsyncProcess.
        var command = commandLine.join(" ");
        debug "$ ${command}"
        var spawned, exitCode, output = $(command);
        if(exitCode != 0) {
            // FIXME: IceTea should do this.
            for(var _,line in output[1].trim().split("\n")) {
                print "STDOUT:\t${line}"
            }
            for(var _,line in output[2].trim().split("\n")) {
                print "STDERR:\t${line}"
            }
            return false;
        }
        return true;
    },
    clean: function() {
        return pfs.remove(@out);
    }
}

// Steps:
step([
    "*.cc", "*.cpp",
    "*.cxx", "*.cpp",
    "*.c++"
], "*.o")(extends NativeStep {
    name: "C++"
})

step(["*.c", "*.C"], "*.o")(extends NativeStep {
    name: "C"
})

step(["*.m"], "*.o")(extends NativeStep {
    name: "ObjC"
})

step(["*.mm"], "*.o")(extends NativeStep {
    name: "ObjC++"
})

step(["*.swift"], "*.o")(extends NativeStep {
    name: "Swift"
})

// Rules:
rule("exe", "Executable") {
    pattern: (sys.type=='unix'
        ? '%o/%t'
        : '%o/%t.exe'
    ),
    configure: function() {
        // FIXME: We kinda need to think, if this is wise.
        // Let's say someone only uses C sources. They will not need a C++ compiler.
        // Alternatively, we should use ld or link.exe respectively.
        // However, I have yet to learn ld...
        detect.compiler("c++");
    },
    build: function() {
        var commandLine = [];
        var settings = ("LINK" in @target.settings
            ? @target.settings.LINK
            : {}
        );

        commandLine.push(detect.compiler("c++"));

        if(sys.type == "windows") {
            commandLine.push("/nologo");
        }

        var libFlag = (sys.type == "unix"
            ? "-l" // GCC and Clang use -l as prefix. I.e.: -lfoo
            : ""   // Windows has none.
        );
        var libDirFlag = (sys.type == "unix"
            ? "-L"          // -L./folder
            : "/LIBPATH:"   // Windows...
        );

        // The first one to add is the output folder.
        // We might be building libs into this, too.
        commandLine.push(libDirFlag .. __outputdir);

        if("libraryDirs" in settings) {
            for(var _,libDir in settings.libraryDirs) {
                commandLine.push(libDirFlag .. libDir);
            }
        }

        if("libraries" in settings) {
            for(var _,lib in settings.libraries) {
                // Be careful. This might actually be a full path.
                // This check is not perfect, but it'll be in the future.
                var libAsFile = pfs.join(__outputdir, lib);
                if(pfs.isPresent(libAsFile)) {
                    commandLine.push(libAsFile);
                } else {
                    commandLine.push(libFlag .. lib);
                }
            }
        }

        commandLine.push(@in.join(" ")); // As this is a rule, our input is an array.
        commandLine.push((sys.type == "unix"
            ? "-o"  // GCC and Clang
            : "/Fe"
        )..@out);

        if("flags" in settings) {
            for(var _,flag in settings.flags) {
                commandLine.push(flag);
            }
        }

        var command = commandLine.join(" ");
        debug "$ ${command}"
        var spawned, exitCode, output = $(command);
        if(exitCode != 0) {
            // FIXME: IceTea should do this.
            for(var _,line in output[1].trim().split("\n")) {
                print "STDOUT:\t${line}"
            }
            for(var _,line in output[2].trim().split("\n")) {
                print "STDERR:\t${line}"
            }
            return false;
        }
        return true;
    },
    clean: function() {
        return true;
    }
}


rule("lib", "Static Library") {
    pattern: (sys.type=='unix'
        ? '%o/lib%t.a'
        : '%o/%t.lib'
    ),
    configure: function() {
        return detect.tool("ar");
    },
    build: function() {
        var command = [
            "ar",
            "rcs",
            @out,
            @{
                var ins = [];
                for(var _,file in @in) {
                    debug "Testing: ${file}"
                    if(file == "null" || typeOf(file) == "null") {
                        debug "Where is this null coming from? ${@in}"
                        continue;
                    }
                    ins.push(file);
                }
                return ins.join(" ")
            }
        ].join(" ");
        debug "$ ${command}"
        var spawned, exitCode, output = $(command);
        if(exitCode != 0) {
            // FIXME: IceTea should do this.
            for(var _,line in output[1].trim().split("\n")) {
                print "STDOUT:\t${line}"
            }
            for(var _,line in output[2].trim().split("\n")) {
                print "STDERR:\t${line}"
            }
            return false;
        }
        return true;

    },
    clean: function() {
        return true;
    }
}
