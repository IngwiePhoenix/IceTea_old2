SettingsContainer = extends Object {
    __construct: function() {
        @stores = arguments;
    },
    __get: function(key) {
        for(var _,store in @stores) {
            if(key in store) {
                return store[key];
            }
        }
        return null;
    },
    __isset: function(key) {
        for(var _,store in @stores) {
            if(key in store) {
                return true;
            }
        }
        return false;
    },
    __getCombined: function(key) {
        debug "${@__name}::__getCombined: ${key}"
        var start = null;
        for(var id,store in @stores) {
            debug "ID: ${id}"
            if(key in store) {
                if(typeOf(start) == "null") {
                    start = store[key];
                } else {
                    var v = store[key];
                    start += v;
                }
            }
            debug "Start: ${start}"
        }
        debug "--> ${start}"
        return start;
    }
}

NativeStep = extends Object {
    // Native objects always have .o or .obj. So, we can groundwire this.
    pattern: (sys.type=='unix'
        ? '%o/.%t/%b.o'
        : '%o/.%t/%b.obj'
    ),

    // All that this configure() function does, is to look for the compiler.
    configure: function() {
        return detect.findCompiler(detect.name2kind(@name));
    },

    // Build
    build: function() {
        var kind = detect.name2kind(@backend.name);
        var compiler = detect.activeCompilerMap[kind];
        var container = SettingsContainer(
            kind in IceTea.GlobalSettings ? IceTea.GlobalSettings[kind] : {},
            "native" in @target.settings ? @target.settings.native : {},
            kind in @target.settings ? @target.settings[kind] : {}
        );

        var includeDirs = container.__getCombined("includeDirs");
        var defines = container.__getCombined("defines");
        var flags = container.__getCombined("flags");
        var warnings = container.__getCombined("warnings");
        var allErrors = container.allErrors;
        var forceIncludes = container.__getCombined("forceIncludes");
        var optimize = container.optimize || "none";
        var shouldDebug = container.shouldDebug;

        pfs.mkdir(pfs.dirname(@out));

        @cmd = compiler.buildCommand(
            @in, @out,
            includeDirs, warnings, defines,
            flags, optimize, forceIncludes,
            false, shouldDebug, allErrors
        );
        debug "$ ${@cmd}"
        // Let the fun begin! :P
        @runner = SubProcess({async: true});
        @spawned = @runner.execute(@cmd);
        return null;
    },
    status: function() {
        var T = IceTea.Task.Status;
        if(@runner.tick()) {
            debug "${@out}: Pending still."
            return T.PENDING; // Not done yet.
        } else {
            debug "${@out}: Task complete. Placing output."
            var stdout = @runner.stdout();
            var stderr = @runner.stderr();
            var color = !cli.check("--no-color");
            var headed = false;
            if(#stdout>0) echo "\n" .. stdout.trim();
            if(#stderr>0) {
                var lines = stderr.trim().split("\n");
                for(var i=0; i<#lines; i++) {
                    lines[i] = "> " .. lines[i];
                }
                echo "\n" .. lines.join("\n").trim();
            }
            if(#stdout>0 || #stderr>0) echo "\n";
            // Done. Check status.
            if(@runner.exit_code() == 0) {
                return T.OK;
            } else {
                print "Failed command: $ ${@cmd}"
                print "Exit code: ${@runner.exit_code()}"
                return T.FAIL;
            }
        }
    },
    clean: function() {
        return pfs.remove(@out);
    }
}

// Steps:
step([
    "*.cc", "*.cpp",
    "*.cxx", "*.cpp",
    "*.c++"
], "*.o")(extends NativeStep {
    name: "C++"
})

step(["*.c", "*.C"], "*.o")(extends NativeStep {
    name: "C"
})

step(["*.m"], "*.o")(extends NativeStep {
    name: "ObjC"
})

step(["*.mm"], "*.o")(extends NativeStep {
    name: "ObjC++"
})

step(["*.swift"], "*.o")(extends NativeStep {
    name: "Swift"
})

// Rules:
rule("exe", "Executable") {
    pattern: (sys.type=='unix'
        ? '%o/%t'
        : '%o/%t.exe'
    ),
    configure: function() {
        return detect.findLinker();
    },
    build: function() {
        debug "build> Beginning"
        var linker = detect.activeLinker;
        debug "build> Linker: ${linker}"
        var container = SettingsContainer(
            "LINK" in IceTea.GlobalSettings ? IceTea.GlobalSettings.LINK : {},
            "LINK" in @target.settings ? @target.settings.LINK : {}
        );

        var libraries = container.__getCombined("libraries") || [];
        var libraryDirs = container.__getCombined("libraryDirs") || [];
        var flags = container.__getCombined("flags");

        @cmd = linker.linkCommand(
            @in, @out,
            libraries, libraryDirs,
            flags, false, false
        );
        debug "$ ${@cmd}"
        // Let the fun begin! :P
        @runner = SubProcess({async: true});
        @spawned = @runner.execute(@cmd);
        return null;
    },
    status: function() {
        var T = IceTea.Task.Status;
        if(@runner.tick()) {
            return T.PENDING; // Not done yet.
        } else {
            // Done. Check status.
            if(@runner.exit_code() == 0) {
                return T.OK;
            } else {
                var stdout = @runner.stdout();
                var stderr = @runner.stderr();
                if(!cli.check("--detail-output")) {
                    print "";
                }
                var color = !cli.check("--no-color");
                if(#stdout > 0) {
                    color && $.setColor($.Colors.GREEN);
                    print stdout;
                    color && $.resetColor();
                }
                if(#stderr > 0) {
                    color && $.setColor($.Colors.RED);
                    print stderr;
                    color && $.resetColor();
                }
                print "Failed command: ${@cmd}"
                print "Exit code: ${@runner.exit_code()}"
                return T.FAIL;
            }
        }
    },
    clean: function() {
        return true;
    }
}


rule("lib", "Static Library") {
    pattern: (sys.type=='unix'
        ? '%o/lib%t.a'
        : '%o/%t.lib'
    ),
    configure: function() {
        // FIXME: Use StaticLibraryTool.
        return detect.tool("ar");
    },
    modify: function(target) {
        detect.line "Adding library:"
        detect.success "${target.name}"
        target.exports = target.exports + {
            LINK: {
                libraries: [target.name]
            }
        };
    },
    build: function() {
        var command = [
            "ar",
            "rcs",
            @out,
            @{
                var ins = [];
                for(var _,file in @in) {
                    debug "Testing: ${file}"
                    if(file == "null" || typeOf(file) == "null") {
                        debug "Where is this null coming from? ${@in}"
                        continue;
                    }
                    ins.push(file);
                }
                return ins.join(" ")
            }
        ].join(" ");
        debug "$ ${command}"
        var spawned, exitCode, output = $(command);
        if(exitCode != 0) {
            // FIXME: IceTea should do this.
            for(var _,line in output[1].trim().split("\n")) {
                print "STDOUT:\t${line}"
            }
            for(var _,line in output[2].trim().split("\n")) {
                print "STDERR:\t${line}"
            }
            print "Failed: ${command}"
            return false;
        }
        return true;

    },
    clean: function() {
        return true;
    }
}
