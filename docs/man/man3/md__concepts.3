.TH "md__concepts" 3 "Sat Mar 26 2016" "IceTea" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__concepts \- Concepts 
Those are possible designs for feature implementations\&. But, you may like to read them anyway! :)
.PP
Just keep in mind, my TODO list isn't short\&.\&.\&.
.PP
## Projects 
.PP
.nf
1 project({
2     name: "Foo",
3     version: "0\&.0\&.1",
4     by: "Ingwie Phoenix"
5 }) {||
6     target("foo", "exe") {
7         input: ["foo\&.c"]
8     }
9 }

.fi
.PP
.PP
.SS "Toolchain"
.PP
Allow the user to define custom toolchains\&. This allows a project to completely focus on building for either the Web with Emscripten/Cheerp/WASM or even use a custom compiler install like HHVM does!
.PP
This allows great flexibility\&.
.PP
Features:
.IP "\(bu" 2
Inherit the steps of the parent
.IP "\(bu" 2
Mark compatible to other toolchains\&. For instance, a project compiled with your custom clang compiler may actually still be compatible to the native compiler\&.
.PP
.PP
.PP
.nf
1 toolchain("native") {||
2     step(\&.\&.\&.)
3     step(\&.\&.\&.)
4     rule(\&.\&.\&.)
5 }
6 toolchain("emscripten") {||
7     step(\&.\&.\&.)
8     rule(\&.\&.\&.)
9 }
10 toolchain("cheerp", "native") {|super|
11     // super is the scope of the parent\&.
12     step(\&.\&.\&.)
13     step(\&.\&.\&.)
14     rule(\&.\&.\&.)
15 }
16 toolchain("custom-clang") {||
17     // \&.\&.\&.
18     this\&.markCompatible("native");
19 }
20 
21 target("foo", "exe") {
22     toolchain: "cheerp",
23     // \&.\&.\&.
24 }
25 
26 target("l1", "lib") {
27     input: [\&.\&.\&.]
28 }
29 target("l2", "lib") {
30     toolchain: "cheerp",
31     input: [\&.\&.\&.]
32 }
33 target("bar", "exe") {
34     needs: [
35         "l1",
36         "l2"    // <- Error: Target bar can not depend on l2: Toolchains dont match!
37                 // Make sure that either they inherit, marked compatible, or are the same!
38     ]
39 }
.fi
.PP
.PP
.SS "BDD generator"
.PP
\fBIceTea\fP needs some way to test things\&. So test generators should be a thing\&.
.PP
.PP
.nf
1 // build\&.it
2 target("foo", "exe") {\&.\&.\&.}
3 test("Basic", "foo") {
4     scheme: "\&./test/basic_test\&.it",
5     tests: pfs\&.glob("\&./test/basic/", "*_test\&.c")
6 }
.fi
.PP
 
.PP
.nf
// basic_test\&.it
#include <testing_framework\&.h>
#include "<%= pfs\&.filename(@testcase\&.filename) %>\&.h" // i\&.e\&.: foo_test\&.h
int main(int argc, char** argv) {
    <%= @testcase\&.source %>
}

.fi
.PP
 
.PP
.nf
// test/basic/foo_test\&.h
#include <assert\&.h>
// test/basic/foo_test\&.c
int life = 42;
assert(life == 42);

.fi
.PP
.PP
But maybe \fBIceTea\fP should have it's own BDD style stuff too, so it can spin up separate processes just dedicated to testing\&. In fact, it could be used as a general-purpose abstraction tool\&. 
.PP
.nf
1 describe("SubProcess", {||
2     it("can run a sync process", {||
3         // \&.\&.\&.
4         expect(stream[0])\&.toBeEmpty();
5         expect(#stream[1] > 0)\&.toBeTrue();
6     });
7 });

.fi
.PP
.PP
## Rule/Step profiles 
.PP
.nf
1 step("*\&.c", "*\&.o") {
2     pattern: "\&.\&.\&.",
3     configure: function(){},
4     // Same applies for rules\&.
5     profiles: {
6         build: function(){},
7         clean: function(){},
8         install: function(){}
9     },
10     status: function(){}
11 }

.fi
.PP
.PP
.SS "Project relationships"
.PP
.IP "\(bu" 2
Refference nested targets with \fC::\fP\&.
.IP "  \(bu" 4
In this example, we'd have these targets:
.IP "    \(bu" 6
\fCA::a\fP
.IP "    \(bu" 6
\fCB::b\fP 
.PP
.nf
1 project({
2     name: "A",
3     version: "1"
4 }) {||
5     target("a", "lib") {
6         // \&.\&.\&.
7     }
8 }
9 project({
10     name: "B",
11     version: "1"
12 }) {||
13     target("b", "exe") {
14         needs: ["A::a"]
15     }
16 }

.fi
.PP

.PP

.PP

.IP "\(bu" 2
Projects should at best consist of a single file\&. Maybe the \fCbuild\&.it\fP, or subsequent \fC\&.\fBIceTea\fP\fP scripts\&. 
.PP
.nf
1 // Much like require, but:
2 project("\&./deps/minihttp");

.fi
.PP

.IP "\(bu" 2
A project called via \fCproject(path)\fP:
.IP "  \(bu" 4
has it's own, locally scoped \fC\&.\fBIceTea\fP\fP folder\&.
.IP "  \(bu" 4
can export variables by attaching it to the \fCthis\fP object\&.
.PP

.PP
.PP
## Versioned projects 
.PP
.nf
1 project({
2     name: "X",
3     version: "1\&.0\&.2"
4 }) {||
5     target("a","exe") {
6         needs: ["OtherProject@^0\&.1\&.0::foo"]
7     }
8 }

.fi
.PP
.PP
## External packages (ITPM, \fBIceTea\fP Package Manager!!) 
.PP
.nf
1 target("example", "exe") {
2     packages: {
3         // Installs packages via the package manager\&.
4         // The package manager to be "emulated" goes before the name
5         // with a colon\&.
6         // For instance:
7         "clib:jwerle/fs\&.c": "0\&.1\&.1",
8         "conan:Poco": "1\&.6\&.1@lasote/stable"
9     },
10     input: pfs\&.glob("\&./src", "*\&.c") + pfs\&.glob("\&./src", "*\&.cxx")
11 }

.fi
.PP
.PP
In this case, the actual target will change slightly\&. The packages will be downloaded before the configure step\&. If they contain a \fCbuild\&.it\fP file, that one will be run after all the packages are downloaded\&. Once that's done, we resolve the package names into target names\&. A target should tag itself with the package name that it was installed as\&.
.PP
.PP
.nf
1 target("fs_c", "lib") {
2     tag: "jwerle/fs\&.c",
3     input: [\&.\&.\&.]
4 }
.fi
.PP
.PP
The tags are then added to the \fCneeds\fP array\&.
.PP
.PP
.nf
1 // It could become this:
2 var target = IceTea\&.__targets\&.example;
3 target\&.needs = target\&.needs || [];
4 target\&.needs += IceTea\&.tag("jwerle/fs\&.c");
5 target\&.needs += IceTea\&.tag("Poco");
.fi
.PP
.PP
However, the package is \fBnot\fP required to export it's target via tagging\&. Instead, it can also use the project-target architecture, and have a \fCpackage\&.it\fP file that could look like this:
.PP
.PP
.nf
1 package("jwerle/fs\&.c") {
2     provides: ["jwerle::fs\&.c"],
3     dependencies: {
4         // A package can depend on others too\&.
5         // If this is found, then we re-run the process as often as needed
6         // untill we have all packages\&.
7         // HOWEVER: Due to limitations in C and C++, we can only have one
8         // version of a package installed!
9         // So if two packages want two incompatible dependencies, that wont work\&.
10     }
11 }
.fi
.PP
.PP
In this case, we simply look up the package, see what it provides and add that into the target that wanted it!
.PP
But even if that is not provided, the user is the poor one that has to specify it himself\&.\&.\&. :)\&. However, that might also be useful\&. Imagine you are having a package that provides two versions: One with backwards compatibility and one that breaks the ABI\&. Take for example FLTK\&. By defining the \fCFL_ABI_VERSION\fP macro, you can basically kill BC\&. So what you could do:
.PP
.PP
.nf
1 target("app", "exe") {
2     packages: {
3         "git:fltk/fltk": "#master"
4     },
5     needs: [
6         "FLTK@abi-1\&.4::FLTK"
7     ]
8 }
.fi
.PP
 Boom\&. Just like that, we will compile with an abi-breaking FLTK!
.PP
But what we might also could do is to allow a package to specify a callback to determine what it wants to add\&. Taking the example from above, imagine a setting: 
.PP
.nf
1 target("app", "exe") {
2     packages: {
3         "git:fltk/fltk": "#master"
4     },
5     settings: {
6         FLTK: {
7             useFutureABI: true
8         }
9     }
10 }

.fi
.PP
 
.PP
.nf
1 // FLTK/package\&.it
2 package("fltk/fltk") {
3     inject: function(target) {
4         if("FLTK" in target\&.settings) {
5             if(target\&.settings\&.FLTK\&.useFutureABI) {
6                 target\&.needs += [
7                     "FLTK@abi-1\&.4::FLTK"
8                 ]
9             }
10         }
11     }
12 }

.fi
.PP
.PP
And, yes, you can also specify multiple packages in one \fCpackage\&.it\fP file, if you published it under various names :)\&.
.PP
.SS "Compatibility to package\&.json"
.PP
Simply add an \fCicetea\fP key to it, and attach the same settings as above\&. For instance:
.PP
.PP
.nf
1 {
2     "name": "fltk/fltk",
3     "version": "1\&.3\&.3",
4     "icetea": {
5         "fltk/fltk": {
6             "provides": [
7                 "FLTK::FLTK"
8             ],
9             "dependencies": {}
10         }
11     }
12 }
.fi
.PP
.PP
.SS "Implementing a package manager"
.PP
Now that I have talked about how they could look like, this is how I could imagine them being implemented\&. Once \fBIceTea\fP has built itself, it has mbedTLS and miniHTTP inside, allowing it to call Github APIs and other neat things\&.
.PP
So, take for instance you have a little self-hosted package manager\&.\&.\&. 
.PP
.nf
1 var MyPM = extends AbstractPackageManager {
2     __construct: function() {
3         // The first time it is found, its constructed\&.
4     },
5     install: function(name, version) {
6         // Install the package\&. Feel free to re-call this method for sub-instals\&.
7         // For instance, for installing dependencies of the dependency\&.
8     },
9     info: function(name, version) {
10         return {
11             // A path to a package\&.it file
12             package_it: "\&.\&.\&.",
13             // Information deserialized from a JSON
14             json: {/*\&.\&.\&.*/},
15             // \&.\&.\&. to be extended \&.\&.\&.
16         }
17     },
18     isEverythingCompatible: function(deps) {
19         // Return true, if it is safe to install all of these\&.
20         // VERY\&. IMPORTANT\&. NOTE\&.
21         // If you take NPM, it will have nested dependencies, since JavaScript is not so strict\&.
22         // ObjectScript also won't mind\&.
23         // Therefore, each package manager should decide individually if nesting is OK or not\&.
24         // For instance, there will be two package managers:
25         // - One for plain ObjectScript based stuff in icetea_modules
26         // - Native dependencies in deps/\&.
27         // Native dependencies cant be mixed - but scripted ones, can\&.
28     }
29 }
30 PackageManager\&.add {
31     name: "mypm",
32     description: "My awesome package manager\&.",
33     version: "0\&.0\&.1-dev"
34     class: MyPM,
35 }

.fi
.PP
.PP
You can obtain additional package managers from existing ones\&. Once a package was downloaded, we immediately run it's \fCpackage\&.it\fP\&. That means, that we won't even know that the next one in the list might not have existed before!
.PP
.PP
.nf
1 package("IngwiePhoenix/demo") {
2     dependencies: {
3         "git:icetea/npm\&.it": "#master",
4         "npm:node-gyp": "\&.\&.\&."
5     }
6 }
.fi
.PP
.PP
.SS "Package scripts"
.PP
A package most commonly has scripts before, after or during its installing\&. So\&.\&.\&. 
.PP
.nf
1 package("IngwiePhoenix/demo") {
2     provides: ["demo"],
3     scripts: {
4         // Before the installation\&.\&.\&.
5         preInstall: function(){},
6         // Replace the installation step\&. By default there is none\&. So add one if you want\&.
7         install: function() {
8             print "I was installed!"
9         },
10         // After installation
11         postInstall: function(){},
12 
13         // You can also add custom scripts\&.
14         // I\&.e\&.: icetea --pm deploy
15         // Instead of running your usual building,
16         // switch IceTea to PackageManager mode so it can
17         // run your scripts\&.
18         // Also, feel free to use the cli object!
19         deploy: function() {
20             // \&.\&.\&.
21         }
22     },
23     // Executed straight after the package file was loaded\&.
24     load: function(){
25         _G\&.demo = true;
26     }
27 }

.fi
.PP
.PP
.SS "Install stuff!"
.PP
All the cool kids have it, but we currently don't\&. So! An install step\&.
.IP "\(bu" 2
Install arbitary files
.IP "\(bu" 2
Install headers, libraries, executables into a prefix
.PP
.PP
.PP
.nf
1 target("mylib", "shlib") {
2     input: [/* \&.\&.\&. */],
3     settings: {
4         native: {
5             reallocateable: true // -fPIC
6         },
7         install: {
8             // Which headers?
9             headers: pfs\&.glob("src/", "*\&.h"),
10             // Or drop the headers all into a relative path\&.
11             headers: {
12                 "mylib": pfs\&.glob("src/","*\&.h")
13             },
14 
15             // Since this is a dynamic library, it'll be copied into \&.\&.\&./lib
16             // automatically\&. So we can set some stuff for that
17 
18             // Library name for OSX for instance
19             libraryName: "mylib",
20             // OS X: Install name
21             installName: "@rpath/libmylib\&.dylib",
22             // OS X: Version to be stanced into the file
23             dylibVersion: "0\&.0\&.0"
24 
25             // More options might come\&.
26             // The rule specified must have an install profile\&.
27             // It is responsible for installing the library, at that point\&.
28         }
29     }
30 }
.fi
.PP
.PP
.SS "NodeJS integration"
.PP
Emscripten is neat\&. In fact, \fBIceTea\fP can now almost compile in it too! The only problem: Well, there is no \fCfork()\fP\&.
.PP
I want to distribute \fBIceTea\fP in JS format to NPM and use it as the build script to build itself\&. 
.PP
.nf
1 {
2     "name": "icetea",
3     "version": "0\&.2\&.0",
4     "main": "js-lib/main",
5     "scripts": {
6         "build": "node dist/icetea\&.js node",
7         "pre-publish": "node build\&.js --dist"
8     }
9 }

.fi
.PP
.PP
Then we could expose an actual NodeJS API to utilize \fBIceTea\fP as a build tool for\&.\&.well, whatever! Use \fBIceTea\fP as the build engine, but write your stuff in JavaScript/ObjectScript\&.\&.\&. huh, interesting, no? Just think about it; you could provide plugins to \fBIceTea\fP, extending it a lot\&. We'd expose the \fBIceTea\fP class, which is an ObjectScript instance\&.\&.\&.aaaand would allow this:
.PP
.PP
.nf
1 var IceTea = require("icetea");
2 var it = IceTea\&.create();
3 
4 // Setup argc/argv
5 it\&.setupCli(
6     process\&.argv\&.length,
7     process\&.argv
8 );
9 
10 // Export a function\&.
11 function Foo(it) {
12     it\&.pushString("bar");
13     return 1;
14 }
15 it\&.getModule("jS");
16 it\&.pushJSFunction(Foo);
17 it\&.setProperty(-2, "Foo");
18 
19 it\&.eval("JS\&.Foo()");
.fi
.PP
 
