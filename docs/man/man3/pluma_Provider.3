.TH "pluma::Provider" 3 "Sat Mar 26 2016" "IceTea" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pluma::Provider \- Interface to provide applications with objects from plugins\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Provider\&.hpp>\fP
.PP
Inherited by \fBIceTeaPluginProvider\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~Provider\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBgetVersion\fP () const  =0"
.br
.RI "\fIGet provider version\&. \fP"
.ti -1c
.RI "bool \fBisCompatible\fP (const \fBHost\fP &host) const "
.br
.RI "\fICheck compatibility with host\&. \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBHost\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Interface to provide applications with objects from plugins\&. 

The plugin specific implementations are unknown at the host side, only their shared interfaces are known\&.
.PP
Then, host app needs a generic way of create interface objects\&. That's what provider classes are for\&. It is the factory design pattern (http://www.oodesign.com/factory-pattern.html)
.PP
Shared interfaces define their provider types (by inheriting from \fBpluma::Provider\fP)\&. Hosts then use those tipes to get objects from the plugins\&. Plugins derive the shared interface providers so that they can provide host with specific implementations of the shared interface\&. Those specific providers are given to the host through a connect function\&.
.PP
Example: A host app uses objects of type Device\&. A certain plugin defines a Keyboard, witch is a Device\&. The \fBHost\fP will use DeviceProviders to create objects of type Device\&. The plugin will provide host specifically with a KeyboardProvider\&. Other plugins may provide host with other derived DeviceProvider types\&.
.PP
Device hpp (shared): 
.PP
.nf
#include <Pluma/Pluma\&.hpp>
class Device{
public:
    virtual std::string getDescription() const = 0;
};
// create DevicedProvider class
PLUMA_PROVIDER_HEADER(Device);

.fi
.PP
.PP
Device cpp (shared): 
.PP
.nf
#include "Device\&.hpp"
generate DevicedProvider with version 6, and compatible with at least v\&.3
PLUMA_PROVIDER_SOURCE(Device, 6, 3);

.fi
.PP
.PP

.br
 Keyboard code on the plugin side: 
.PP
.nf
#include <Pluma/Pluma\&.hpp>
#include "Device\&.hpp"

class Keyboard: public Device{
public:
    std::string getDescription() const{
        return "keyboard";
    }
};

// create KeyboardProvider, it implements DeviceProvider
PLUMA_INHERIT_PROVIDER(Keyboard, Device);

.fi
.PP
.PP
plugin connector: 
.PP
.nf
#include <Pluma/Connector\&.hpp>
#include "Keyboard\&.hpp"

PLUMA_CONNECTOR
bool connect(pluma::Host& host){
    // add a keyboard provider to host
    host\&.add( new KeyboardProvider() );
    return true;
}

.fi
.PP
.PP
\fBHost\fP application code: 
.PP
.nf
#include <Pluma/Pluma\&.hpp>

#include "Device\&.hpp"
#include <iostream>
#include <vector>

int main(){

    pluma::Pluma plugins;
    // Tell plugins manager to accept providers of the type DeviceProvider
    plugins\&.acceptProviderType<DeviceProvider>();
    // Load library "standard_devices" from folder "plugins"
    plugins\&.load("plugins", "standard_devices");

    // Get device providers into a vector
    std::vector<DeviceProvider*> providers;
    plugins\&.getProviders(providers);

    // create a Device from the first provider
    if (!providers\&.empty()){
        Device* myDevice = providers\&.first()->create();
        // do something with myDevice
        std::cout << device->getDescription() << std::endl;
        // and delete it in the end
        delete myDevice;
    }
    return 0;
}

.fi
.PP
 
.PP
Definition at line 42 of file Provider\&.hpp\&.
.SH "Member Function Documentation"
.PP 
.SS "virtual unsigned int pluma::Provider::getVersion () const\fC [pure virtual]\fP"

.PP
Get provider version\&. 
.PP
\fBReturns:\fP
.RS 4
Version number\&. 
.RE
.PP

.PP
Implemented in \fBIceTeaPluginProvider\fP\&.
.SS "bool pluma::Provider::isCompatible (const \fBHost\fP & host) const"

.PP
Check compatibility with host\&. The same provider may be compiled with different versions on host side and on plugins side\&. This function checks if a plugin provider is compatible with the current version of the same provider type on the host side\&.
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP \fBHost\fP, proxy of host application\&.
.RE
.PP
\fBReturns:\fP
.RS 4
True if it's compatible with \fIhost\fP\&. 
.RE
.PP

.PP
Definition at line 42 of file Provider\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for IceTea from the source code\&.
