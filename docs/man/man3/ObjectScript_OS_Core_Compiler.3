.TH "ObjectScript::OS::Core::Compiler" 3 "Sat Mar 26 2016" "IceTea" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ObjectScript::OS::Core::Compiler \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBDebugInfoItem\fP"
.br
.ti -1c
.RI "struct \fBExpression\fP"
.br
.ti -1c
.RI "struct \fBExpressionList\fP"
.br
.ti -1c
.RI "struct \fBLocalVarDesc\fP"
.br
.ti -1c
.RI "struct \fBParams\fP"
.br
.ti -1c
.RI "struct \fBScope\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBExpressionType\fP { \fBEXP_TYPE_UNKNOWN\fP, \fBEXP_TYPE_NOP\fP, \fBEXP_TYPE_NEW_LOCAL_VAR\fP, \fBEXP_TYPE_SCOPE\fP, \fBEXP_TYPE_LOOP_SCOPE\fP, \fBEXP_TYPE_FOR_LOOP_SCOPE\fP, \fBEXP_TYPE_CODE_LIST\fP, \fBEXP_TYPE_NAME\fP, \fBEXP_TYPE_POP_VALUE\fP, \fBEXP_TYPE_SUPER_CALL\fP, \fBEXP_TYPE_CALL\fP, \fBEXP_TYPE_CALL_AUTO_PARAM\fP, \fBEXP_TYPE_CALL_DIM\fP, \fBEXP_TYPE_VALUE\fP, \fBEXP_TYPE_PARAMS\fP, \fBEXP_TYPE_FUNCTION\fP, \fBEXP_TYPE_EXTENDS\fP, \fBEXP_TYPE_DELETE\fP, \fBEXP_TYPE_RETURN\fP, \fBEXP_TYPE_BREAK\fP, \fBEXP_TYPE_CONTINUE\fP, \fBEXP_TYPE_DEBUGGER\fP, \fBEXP_TYPE_DEBUG_LOCALS\fP, \fBEXP_TYPE_IF\fP, \fBEXP_TYPE_QUESTION\fP, \fBEXP_TYPE_TRY_CATCH\fP, \fBEXP_TYPE_THROW\fP, \fBEXP_TYPE_ARRAY\fP, \fBEXP_TYPE_OBJECT\fP, \fBEXP_TYPE_OBJECT_SET_BY_NAME\fP, \fBEXP_TYPE_OBJECT_SET_BY_INDEX\fP, \fBEXP_TYPE_OBJECT_SET_BY_EXP\fP, \fBEXP_TYPE_OBJECT_SET_BY_AUTO_INDEX\fP, \fBEXP_TYPE_OBJECT_CREATE_CONST\fP, \fBEXP_TYPE_SUPER\fP, \fBEXP_TYPE_GET_THIS\fP, \fBEXP_TYPE_GET_ARGUMENTS\fP, \fBEXP_TYPE_GET_REST_ARGUMENTS\fP, \fBEXP_TYPE_GET_LOCAL_VAR\fP, \fBEXP_TYPE_GET_LOCAL_VAR_AUTO_CREATE\fP, \fBEXP_TYPE_SET_LOCAL_VAR\fP, \fBEXP_TYPE_SET_LOCAL_VAR_NO_POP\fP, \fBEXP_TYPE_SET_LOCAL_VAR_BY_BIN_OPERATOR_LOCALS\fP, \fBEXP_TYPE_SET_LOCAL_VAR_BY_BIN_OPERATOR_LOCAL_AND_NUMBER\fP, \fBEXP_TYPE_GET_ENV_VAR\fP, \fBEXP_TYPE_GET_ENV_VAR_AUTO_CREATE\fP, \fBEXP_TYPE_SET_ENV_VAR\fP, \fBEXP_TYPE_SET_ENV_VAR_NO_POP\fP, \fBEXP_TYPE_INDIRECT\fP, \fBEXP_TYPE_GET_PROPERTY\fP, \fBEXP_TYPE_GET_PROPERTY_AUTO_CREATE\fP, \fBEXP_TYPE_SET_PROPERTY\fP, \fBEXP_TYPE_INIT_PROPERTY\fP, \fBEXP_TYPE_SET_PROPERTY_NO_POP\fP, \fBEXP_TYPE_GET_THIS_PROPERTY_BY_STRING\fP, \fBEXP_TYPE_GET_PROPERTY_BY_LOCALS\fP, \fBEXP_TYPE_GET_PROPERTY_BY_LOCAL_AND_NUMBER\fP, \fBEXP_TYPE_SET_PROPERTY_BY_LOCALS_AUTO_CREATE\fP, \fBEXP_TYPE_GET_SET_PROPERTY_BY_LOCALS_AUTO_CREATE\fP, \fBEXP_TYPE_SET_DIM\fP, \fBEXP_TYPE_SET_DIM_NO_POP\fP, \fBEXP_TYPE_CALL_METHOD\fP, \fBEXP_TYPE_INIT_ITER\fP, \fBEXP_TYPE_TAIL_CALL\fP, \fBEXP_TYPE_TAIL_CALL_METHOD\fP, \fBEXP_TYPE_CONST_NULL\fP, \fBEXP_TYPE_CONST_NUMBER\fP, \fBEXP_TYPE_CONST_STRING\fP, \fBEXP_TYPE_CONST_TRUE\fP, \fBEXP_TYPE_CONST_FALSE\fP, \fBEXP_TYPE_LOGIC_BOOL\fP, \fBEXP_TYPE_LOGIC_NOT\fP, \fBEXP_TYPE_BIT_NOT\fP, \fBEXP_TYPE_PLUS\fP, \fBEXP_TYPE_MINUS\fP, \fBEXP_TYPE_LENGTH\fP, \fBEXP_TYPE_IN\fP, \fBEXP_TYPE_IS\fP, \fBEXP_TYPE_AS\fP, \fBEXP_TYPE_BIN_OPERATOR_BY_LOCALS\fP, \fBEXP_TYPE_BIN_OPERATOR_BY_LOCAL_AND_NUMBER\fP, \fBEXP_TYPE_CONCAT\fP, \fBEXP_TYPE_BEFORE_INJECT_VAR\fP, \fBEXP_TYPE_AFTER_INJECT_VAR\fP, \fBEXP_TYPE_LOGIC_AND\fP, \fBEXP_TYPE_LOGIC_OR\fP, \fBEXP_TYPE_LOGIC_PTR_EQ\fP, \fBEXP_TYPE_LOGIC_PTR_NE\fP, \fBEXP_TYPE_LOGIC_EQ\fP, \fBEXP_TYPE_LOGIC_NE\fP, \fBEXP_TYPE_LOGIC_GE\fP, \fBEXP_TYPE_LOGIC_LE\fP, \fBEXP_TYPE_LOGIC_GREATER\fP, \fBEXP_TYPE_LOGIC_LESS\fP, \fBEXP_TYPE_PRE_INC\fP, \fBEXP_TYPE_PRE_DEC\fP, \fBEXP_TYPE_POST_INC\fP, \fBEXP_TYPE_POST_DEC\fP, \fBEXP_TYPE_BIT_AND\fP, \fBEXP_TYPE_BIT_OR\fP, \fBEXP_TYPE_BIT_XOR\fP, \fBEXP_TYPE_BIT_AND_ASSIGN\fP, \fBEXP_TYPE_BIT_OR_ASSIGN\fP, \fBEXP_TYPE_BIT_XOR_ASSIGN\fP, \fBEXP_TYPE_BIT_NOT_ASSIGN\fP, \fBEXP_TYPE_COMPARE\fP, \fBEXP_TYPE_ADD\fP, \fBEXP_TYPE_SUB\fP, \fBEXP_TYPE_MUL\fP, \fBEXP_TYPE_DIV\fP, \fBEXP_TYPE_MOD\fP, \fBEXP_TYPE_LSHIFT\fP, \fBEXP_TYPE_RSHIFT\fP, \fBEXP_TYPE_POW\fP, \fBEXP_TYPE_ADD_ASSIGN\fP, \fBEXP_TYPE_SUB_ASSIGN\fP, \fBEXP_TYPE_MUL_ASSIGN\fP, \fBEXP_TYPE_DIV_ASSIGN\fP, \fBEXP_TYPE_MOD_ASSIGN\fP, \fBEXP_TYPE_LSHIFT_ASSIGN\fP, \fBEXP_TYPE_RSHIFT_ASSIGN\fP, \fBEXP_TYPE_POW_ASSIGN\fP, \fBEXP_TYPE_ASSIGN\fP, \fBEXP_TYPE_GET_UPVALUE\fP, \fBEXP_TYPE_SET_UPVALUE\fP, \fBEXP_TYPE_SET_UPVALUE_NO_POP\fP, \fBEXP_TYPE_MOVE\fP, \fBEXP_TYPE_GET_XCONST\fP, \fBEXP_TYPE_SWITCH_SCOPE\fP, \fBEXP_TYPE_CASE\fP, \fBEXP_TYPE_CASE_DEFAULT\fP, \fBEXP_TYPE_CASE_JUMP\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCompiler\fP (\fBTokenizer\fP *)"
.br
.ti -1c
.RI "bool \fBcompile\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBEXPRESSION_SIZE\fP = sizeof(\fBExpression\fP)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum \fBELocalVarScopeType\fP { \fBLOCAL_GENERIC\fP, \fBLOCAL_PARAM\fP, \fBLOCAL_TEMP\fP }"
.br
.ti -1c
.RI "enum \fBECompiledValueType\fP { \fBCVT_UNKNOWN\fP, \fBCVT_NUMBER\fP, \fBCVT_DYNAMIC\fP }"
.br
.ti -1c
.RI "enum \fBErrorType\fP { \fBERROR_NOTHING\fP, \fBERROR_SYNTAX\fP, \fBERROR_NESTED_ROOT_BLOCK\fP, \fBERROR_LOCAL_VAL_NOT_DECLARED\fP, \fBERROR_VAR_NAME\fP, \fBERROR_EXPECT_TOKEN_TYPE\fP, \fBERROR_EXPECT_TOKEN_STR\fP, \fBERROR_EXPECT_TOKEN\fP, \fBERROR_EXPECT_VALUE\fP, \fBERROR_EXPECT_WRITEABLE\fP, \fBERROR_EXPECT_GET_OR_SET\fP, \fBERROR_EXPECT_EXPRESSION\fP, \fBERROR_EXPECT_FUNCTION_SCOPE\fP, \fBERROR_EXPECT_CODE_SEP_BEFORE_NESTED_BLOCK\fP, \fBERROR_EXPECT_SWITCH_SCOPE\fP, \fBERROR_EXPECT_LOOP_SCOPE\fP, \fBERROR_FINISH_BINARY_OP\fP, \fBERROR_FINISH_UNARY_OP\fP }"
.br
.ti -1c
.RI "enum \fBOpcodeLevel\fP { \fBOP_LEVEL_NOTHING\fP = -1, \fBOP_LEVEL_0\fP, \fBOP_LEVEL_1\fP, \fBOP_LEVEL_1_1\fP, \fBOP_LEVEL_2\fP, \fBOP_LEVEL_3\fP, \fBOP_LEVEL_4\fP, \fBOP_LEVEL_5\fP, \fBOP_LEVEL_6\fP, \fBOP_LEVEL_7\fP, \fBOP_LEVEL_8\fP, \fBOP_LEVEL_9\fP, \fBOP_LEVEL_10\fP, \fBOP_LEVEL_11\fP, \fBOP_LEVEL_12\fP, \fBOP_LEVEL_13\fP, \fBOP_LEVEL_14\fP, \fBOP_LEVEL_15\fP, \fBOP_LEVEL_16\fP, \fBOP_LEVEL_COUNT\fP }"
.br
.ti -1c
.RI "enum \fBEFilenameType\fP { \fBGET_FILENAME\fP, \fBGET_DIRNAME\fP }"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBisError\fP ()"
.br
.ti -1c
.RI "void \fBresetError\fP ()"
.br
.ti -1c
.RI "void \fBsetError\fP ()"
.br
.ti -1c
.RI "void \fBsetError\fP (ErrorType value, \fBTokenData\fP *error_token)"
.br
.ti -1c
.RI "void \fBsetError\fP (TokenType expect_token_type, \fBTokenData\fP *error_token)"
.br
.ti -1c
.RI "void \fBsetError\fP (const \fBString\fP &str, \fBTokenData\fP *error_token)"
.br
.ti -1c
.RI "void * \fBmalloc\fP (int size)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBsetNextTokenIndex\fP (int i)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBsetNextToken\fP (\fBTokenData\fP *token)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBputNextTokenType\fP (TokenType tokenType)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBungetToken\fP ()"
.br
.ti -1c
.RI "bool \fBisNextTokens\fP (TokenType *list, int count)"
.br
.ti -1c
.RI "bool \fBisNextToken\fP (TokenType t0)"
.br
.ti -1c
.RI "bool \fBisNextTokens\fP (TokenType t0, TokenType t1)"
.br
.ti -1c
.RI "bool \fBisNextTokens\fP (TokenType t0, TokenType t1, TokenType t2)"
.br
.ti -1c
.RI "bool \fBisNextTokens\fP (TokenType t0, TokenType t1, TokenType t2, TokenType t3)"
.br
.ti -1c
.RI "void \fBdeleteNops\fP (\fBExpressionList\fP &list)"
.br
.ti -1c
.RI "ExpressionType \fBgetUnaryExpressionType\fP (TokenType)"
.br
.ti -1c
.RI "ExpressionType \fBgetExpressionType\fP (TokenType)"
.br
.ti -1c
.RI "OpcodeLevel \fBgetOpcodeLevel\fP (ExpressionType exp_type)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBreadToken\fP ()"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBgetPrevToken\fP ()"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBexpectToken\fP (TokenType)"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBexpectToken\fP ()"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectSingleExpression\fP (\fBScope\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectSingleExpression\fP (\fBScope\fP *, bool allow_nop_result=false, bool allow_inline_nested_block=false, bool allow_params=true)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectExpressionValues\fP (\fBExpression\fP *exp, int ret_values, bool auto_no_values=false)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBnewExpressionFromList\fP (\fBExpressionList\fP &list, int ret_values, bool auto_no_values=false)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBnewAssingExpression\fP (\fBScope\fP *scope, \fBExpression\fP *var_exp, \fBExpression\fP *value_exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBnewSingleValueExpression\fP (\fBExpression\fP *exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpostCompileExpression\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpostCompilePass2\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpostCompileFixValueType\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpostCompilePass3\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpostCompileNewVM\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "void \fBregisterUpvalue\fP (\fBScope\fP *scope, \fBExpression\fP *exp)"
.br
.ti -1c
.RI "bool \fBisVarNameValid\fP (const \fBString\fP &name)"
.br
.ti -1c
.RI "\fBScope\fP * \fBexpectTextExpression\fP ()"
.br
.ti -1c
.RI "\fBScope\fP * \fBexpectCodeExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectFunctionExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectFunctionSugarExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectFunctionBlockExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectExtendsExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectDeleteExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectVarExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectObjectOrFunctionExpression\fP (\fBScope\fP *, const \fBParams\fP &p, bool allow_finish_exp=true)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectArrayExpression\fP (\fBScope\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectParamsExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectReturnExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectTryExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectThrowExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectFilenameExpression\fP (\fBScope\fP *, EFilenameType)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectIfExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectWhileExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectDoExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectSwitchExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectCaseExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectForExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectDebugLocalsExpression\fP (\fBScope\fP *)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBexpectBracketExpression\fP (\fBScope\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBfinishValueExpression\fP (\fBScope\fP *, \fBExpression\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBfinishValueExpressionNoAutoCall\fP (\fBScope\fP *, \fBExpression\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBfinishValueExpressionNoNextCall\fP (\fBScope\fP *, \fBExpression\fP *, const \fBParams\fP &p)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBfinishBinaryOperator\fP (\fBScope\fP *scope, OpcodeLevel prev_level, \fBExpression\fP *exp, const \fBParams\fP &p, bool &is_finished)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBfinishQuestionOperator\fP (\fBScope\fP *, \fBTokenData\fP *token, \fBExpression\fP *left_exp, \fBExpression\fP *right_exp)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBnewBinaryExpression\fP (\fBScope\fP *scope, ExpressionType, \fBTokenData\fP *, \fBExpression\fP *left_exp, \fBExpression\fP *right_exp)"
.br
.ti -1c
.RI "bool \fBfindLocalVar\fP (\fBLocalVarDesc\fP &, \fBScope\fP *scope, const \fBString\fP &name, int active_locals, bool all_scopes, bool decl=false)"
.br
.ti -1c
.RI "void \fBdebugPrintSourceLine\fP (\fBBuffer\fP &out, \fBTokenData\fP *)"
.br
.ti -1c
.RI "int \fBcacheString\fP (\fBTable\fP *strings_table, \fBVector\fP< \fBString\fP > &strings, const \fBString\fP &str)"
.br
.ti -1c
.RI "int \fBcacheString\fP (const \fBString\fP &str)"
.br
.ti -1c
.RI "int \fBcacheDebugString\fP (const \fBString\fP &str)"
.br
.ti -1c
.RI "int \fBcacheNumber\fP (double)"
.br
.ti -1c
.RI "void \fBwriteJumpOpcode\fP (int offs)"
.br
.ti -1c
.RI "void \fBfixJumpOpcode\fP (int offs, int pos)"
.br
.ti -1c
.RI "int \fBgetOpcodePos\fP ()"
.br
.ti -1c
.RI "int \fBwriteOpcode\fP (unsigned __int32 opcode)"
.br
.ti -1c
.RI "int \fBwriteOpcode\fP (OpcodeType opcode)"
.br
.ti -1c
.RI "int \fBwriteOpcodeABC\fP (OpcodeType opcode, int a, int b=0, int c=0)"
.br
.ti -1c
.RI "int \fBwriteOpcodeABx\fP (OpcodeType opcode, int a, int b)"
.br
.ti -1c
.RI "void \fBwriteOpcodeAt\fP (unsigned __int32 opcode, int pos)"
.br
.ti -1c
.RI "bool \fBwriteOpcodes\fP (\fBScope\fP *, \fBExpression\fP *)"
.br
.ti -1c
.RI "bool \fBwriteOpcodes\fP (\fBScope\fP *, \fBExpressionList\fP &, bool optimization_enabled=false)"
.br
.ti -1c
.RI "void \fBwriteJumpOpcodeOld\fP (int offs)"
.br
.ti -1c
.RI "void \fBfixJumpOpcodeOld\fP (\fBStreamWriter\fP *writer, int offs, int pos)"
.br
.ti -1c
.RI "void \fBfixJumpOpcodeOld\fP (\fBStreamWriter\fP *writer, int offs, int pos, int opcode)"
.br
.ti -1c
.RI "bool \fBwriteOpcodesOld\fP (\fBScope\fP *, \fBExpression\fP *)"
.br
.ti -1c
.RI "bool \fBwriteOpcodesOld\fP (\fBScope\fP *, \fBExpressionList\fP &)"
.br
.ti -1c
.RI "void \fBwriteDebugInfo\fP (\fBExpression\fP *)"
.br
.ti -1c
.RI "bool \fBsaveToStream\fP (\fBStreamWriter\fP *writer)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const char * \fBgetExpName\fP (ExpressionType, ECompiledValueType=CVT_UNKNOWN)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBOS\fP * \fBallocator\fP"
.br
.ti -1c
.RI "\fBTokenizer\fP * \fBtokenizer\fP"
.br
.ti -1c
.RI "ErrorType \fBerror\fP"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBerror_token\fP"
.br
.ti -1c
.RI "TokenType \fBexpect_token_type\fP"
.br
.ti -1c
.RI "\fBString\fP \fBexpect_token\fP"
.br
.ti -1c
.RI "\fBTokenData\fP * \fBrecent_token\fP"
.br
.ti -1c
.RI "int \fBnext_token_index\fP"
.br
.ti -1c
.RI "\fBTextData\fP * \fBrecent_printed_text_data\fP"
.br
.ti -1c
.RI "int \fBrecent_printed_line\fP"
.br
.ti -1c
.RI "\fBTable\fP * \fBprog_numbers_table\fP"
.br
.ti -1c
.RI "\fBTable\fP * \fBprog_strings_table\fP"
.br
.ti -1c
.RI "\fBVector\fP< double > \fBprog_numbers\fP"
.br
.ti -1c
.RI "\fBVector\fP< \fBString\fP > \fBprog_strings\fP"
.br
.ti -1c
.RI "\fBVector\fP< \fBScope\fP * > \fBprog_functions\fP"
.br
.ti -1c
.RI "\fBVector\fP< unsigned __int32 > \fBprog_opcodes\fP"
.br
.ti -1c
.RI "\fBVector\fP< \fBDebugInfoItem\fP > \fBprog_debug_info\fP"
.br
.ti -1c
.RI "int \fBprog_filename_string_index\fP"
.br
.ti -1c
.RI "int \fBprog_max_up_count\fP"
.br
.ti -1c
.RI "int \fBprog_optimize_offs\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBProgram\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 1610 of file objectscript\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for IceTea from the source code\&.
