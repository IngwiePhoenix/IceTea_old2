\hypertarget{classtthread_1_1recursive__mutex}{}\section{tthread\+:\+:recursive\+\_\+mutex Class Reference}
\label{classtthread_1_1recursive__mutex}\index{tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}}


Recursive mutex class.  




{\ttfamily \#include $<$tinythread.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtthread_1_1recursive__mutex_aa3f7469b6bdb9aca461f55ee03a49726}{recursive\+\_\+mutex} ()\hypertarget{classtthread_1_1recursive__mutex_aa3f7469b6bdb9aca461f55ee03a49726}{}\label{classtthread_1_1recursive__mutex_aa3f7469b6bdb9aca461f55ee03a49726}

\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classtthread_1_1recursive__mutex_ab35d8df5aecdf77cc6e2394ff6aef34d}{$\sim$recursive\+\_\+mutex} ()\hypertarget{classtthread_1_1recursive__mutex_ab35d8df5aecdf77cc6e2394ff6aef34d}{}\label{classtthread_1_1recursive__mutex_ab35d8df5aecdf77cc6e2394ff6aef34d}

\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \hyperlink{classtthread_1_1recursive__mutex_ae8c3a0336f41749be4d8020e6b2c44bc}{lock} ()
\begin{DoxyCompactList}\small\item\em Lock the mutex. \end{DoxyCompactList}\item 
bool \hyperlink{classtthread_1_1recursive__mutex_af52aa48b39013cc2036448314040325d}{try\+\_\+lock} ()
\begin{DoxyCompactList}\small\item\em Try to lock the mutex. \end{DoxyCompactList}\item 
void \hyperlink{classtthread_1_1recursive__mutex_a3a351a53fd737fa9b3ecbe063a17393f}{unlock} ()
\begin{DoxyCompactList}\small\item\em Unlock the mutex. \end{DoxyCompactList}\item 
{\bfseries recursive\+\_\+mutex} (const \hyperlink{classtthread_1_1recursive__mutex}{recursive\+\_\+mutex} \&)\hypertarget{classtthread_1_1recursive__mutex_a36d41e533d43341412905cea767b98b2}{}\label{classtthread_1_1recursive__mutex_a36d41e533d43341412905cea767b98b2}

\item 
\hyperlink{classtthread_1_1recursive__mutex}{recursive\+\_\+mutex} \& {\bfseries operator=} (const \hyperlink{classtthread_1_1recursive__mutex}{recursive\+\_\+mutex} \&)\hypertarget{classtthread_1_1recursive__mutex_a46485e045a4efb1033151279aba311e0}{}\label{classtthread_1_1recursive__mutex_a46485e045a4efb1033151279aba311e0}

\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class {\bfseries condition\+\_\+variable}\hypertarget{classtthread_1_1recursive__mutex_a89c9b6aa2256fa5efd92a333d96381d4}{}\label{classtthread_1_1recursive__mutex_a89c9b6aa2256fa5efd92a333d96381d4}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Recursive mutex class. 

This is a mutual exclusion object for synchronizing access to shared memory areas for several threads. The mutex is recursive (i.\+e. a thread may lock the mutex several times, as long as it unlocks the mutex the same number of times). \begin{DoxySeeAlso}{See also}
\hyperlink{classtthread_1_1mutex}{mutex} 
\end{DoxySeeAlso}


Definition at line 251 of file tinythread.\+h.



\subsection{Member Function Documentation}
\index{tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}!lock@{lock}}
\index{lock@{lock}!tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}}
\subsubsection[{\texorpdfstring{lock()}{lock()}}]{\setlength{\rightskip}{0pt plus 5cm}void tthread\+::recursive\+\_\+mutex\+::lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtthread_1_1recursive__mutex_ae8c3a0336f41749be4d8020e6b2c44bc}{}\label{classtthread_1_1recursive__mutex_ae8c3a0336f41749be4d8020e6b2c44bc}


Lock the mutex. 

The method will block the calling thread until a lock on the mutex can be obtained. The mutex remains locked until {\ttfamily \hyperlink{classtthread_1_1recursive__mutex_a3a351a53fd737fa9b3ecbe063a17393f}{unlock()}} is called. \begin{DoxySeeAlso}{See also}
\hyperlink{classtthread_1_1lock__guard}{lock\+\_\+guard} 
\end{DoxySeeAlso}


Definition at line 280 of file tinythread.\+h.

\index{tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}!try\+\_\+lock@{try\+\_\+lock}}
\index{try\+\_\+lock@{try\+\_\+lock}!tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}}
\subsubsection[{\texorpdfstring{try\+\_\+lock()}{try_lock()}}]{\setlength{\rightskip}{0pt plus 5cm}bool tthread\+::recursive\+\_\+mutex\+::try\+\_\+lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtthread_1_1recursive__mutex_af52aa48b39013cc2036448314040325d}{}\label{classtthread_1_1recursive__mutex_af52aa48b39013cc2036448314040325d}


Try to lock the mutex. 

The method will try to lock the mutex. If it fails, the function will return immediately (non-\/blocking). \begin{DoxyReturn}{Returns}
{\ttfamily true} if the lock was acquired, or {\ttfamily false} if the lock could not be acquired. 
\end{DoxyReturn}


Definition at line 294 of file tinythread.\+h.

\index{tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}!unlock@{unlock}}
\index{unlock@{unlock}!tthread\+::recursive\+\_\+mutex@{tthread\+::recursive\+\_\+mutex}}
\subsubsection[{\texorpdfstring{unlock()}{unlock()}}]{\setlength{\rightskip}{0pt plus 5cm}void tthread\+::recursive\+\_\+mutex\+::unlock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtthread_1_1recursive__mutex_a3a351a53fd737fa9b3ecbe063a17393f}{}\label{classtthread_1_1recursive__mutex_a3a351a53fd737fa9b3ecbe063a17393f}


Unlock the mutex. 

If any threads are waiting for the lock on this mutex, one of them will be unblocked. 

Definition at line 306 of file tinythread.\+h.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{tinythread_8h}{tinythread.\+h}\end{DoxyCompactItemize}
