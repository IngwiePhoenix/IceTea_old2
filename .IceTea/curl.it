/**
 * @file: cURL itnerface for IceTea.
 *
 * I used the configure files as reference for building this file.
 * Some of the more interesting comments are copied unedited (except syntactialy)
 * so that the meaning of some of the things that are done here are preserved.
 *
 * They will be framed by a leading and ending QUOTE or /QUOTE keyword.
 *
 * The main operations are done on the target's CURL object.
 * In it, you will find ports of several functions defined in the .m4 files.
 */

var dep = require("deps");
var CURL_SOURCEDIR = dep.get("curl");
target("curl", "lib") {
    title: "cURL",
    input: [],
    needs: ["mbedtls"],
    // Private variables, used across.
    CURL: {
        // Properties
        sslLibs: [
            "ssl",
            "gnutls",
            "nss",
            "polarssl",
            "mbedtls",
            "cyassl",
            "axtls",
            "winssl",
            "darwinssl"
        ],
        otherLibs: [
            "libssh2",
            "zlib",
            "librtmp",
            "libmetalink",
            "libpsl",
            "libgcc"
        ],
        windowsLibs: [
            "libidn",
            "winidn"
        ],
        genericEnables: [ // Add name defs
            "ipv6",
            "unix-sockets",
            "sspi",
            "libcurl_option"
        ],
        protocols: [
            "http", "ftp", "file",
            "ldap", "ldaps", "rtsp",
            "proxy", "dict", "telnet",
            "tftp", "pop3", "imap", "smb",
            "smtp", "gopher",
        ],

        CURL_INCLUDES_INTTYPES: function() {
            if("_curl_includes_inttypes" in this) return;
            else @_curl_includes_inttypes = true;
            @curl_includes_inttypes_src = [
                "/* includes start */   ",
                "#ifdef HAVE_SYS_TYPES_H",
                "# include <sys/types.h>",
                "#endif                 ",
                "#ifdef HAVE_STDINT_H   ",
                "# include <stdint.h>   ",
                "#endif                 ",
                "#ifdef HAVE_INTTYPES_H ",
                "# include <inttypes.h> ",
                "#endif                 ",
                "/* includes end */     "
            ].join("\n");
            for(var n,hdr in [
                "sys/types.h",
                "stdint.h",
                "inttypes.h"
            ]) detect.header("c", hdr);
        },

        // Methods
        CURL_CONFIGURE_CURL_OFF_T: function() {
            // Deps
            @CURL_INCLUDES_INTTYPES();
            autoconf.AC_SYS_LARGEFILE();
            @CURL_CONFIGURE_REENTRANT();
            @CURL_CHECK_AIX_ALL_SOURCE();

            var found1, size_long = detect.sizeof("long") || return false;
            var found2, size_void = detect.sizeof("void*")|| return false;
            var x_LP64_long, x_LP32_long;
            if(size_long == 8 && size_void > 8) {
                x_LP64_long = "long";
            } else if(size_long == 4 && size_void > 4) {
                x_LP32_long = "long";
            }
            @curl_typeof_curl_off_t = "unknown";
            @curl_sizeof_curl_off_t = "unknown";
            @curl_format_curl_off_t = "unknown";
            @curl_format_curl_off_tu = "unknown";
            detect.line "Checking for 64-bit curl_off_t data type";
            if(@curl_typeof_curl_off_t == "unknown") {
                for(var _,type in [
                    x_LP64_long,
                    "int64_t",
                    "__int64",
                    "long long",
                    "longlong",
                    "__longlong_t"
                ]) {
                    var res = @DO_CURL_OFF_T_CHECK(checkType);
                    if(res) {
                        detect.success(@curl_typeof_curl_off_t);
                        break;
                    }
                }
            }
            detect.fail "None found!";
            detect.line "Checking for 32-bit curl_off_t data type";
            if(@curl_typeof_curl_off_t == "unknown") {
                for(var _,type in [
                    x_LP32_long,
                    "int32_t",
                    "__int32",
                    "int"
                ]) {
                    var res = @DO_CURL_CONFIGURE_CURL_OFF_T(checkType);
                    if(res) {
                        detect.success(@curl_typeof_curl_off_t);
                        break;
                    }
                }
            }
            if(@curl_typeof_curl_off_t == "unknown") {
                detect.abort "Cannot find data type for curl_off_t."
                return false;
            } else {
                detect.line "Checked for size of curl_off_t"
                detect.success(@CURL.curl_typeof_curl_off_t)
            }

            detect.line "Checking for formatting string directive for curl_off_t"
            var x_pull_headers;
            if(@curl_format_curl_off_t != "unknown") {
                x_pull_headers = true;
                var quickSed = function(val, sed, repStr) {
                    var rt, matches = SLRE.match(sed, val);
                    return val.replace(matches[0], repStr);
                }
                @curl_format_curl_off_t
                    = quickSed(@curl_format_curl_off_t, '([["]])', "");
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_t, '(i)$', 'u');
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_tu, '(d)$', 'u');
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_tu, '(D)$', 'U');
            } else {
                x_pull_headers = false;
                switch(@curl_typeof_curl_off_t) {
                    case "long long":
                    case "__longlong":
                    case "__longlong_t":
                        @curl_format_curl_off_t = "lld";
                        @curl_format_curl_off_tu = "llu";
                    break;

                    case "long":
                        @curl_format_curl_off_t = "ld";
                        @curl_format_curl_off_tu = "lu";
                    break;

                    case "int":
                        @curl_format_curl_off_t = "d";
                        @curl_format_curl_off_tu = "u";
                    break;

                    case "__int64":
                        @curl_format_curl_off_t = "I64d";
                        @curl_format_curl_off_tu = "I64u";
                    break;

                    case "__int32":
                        @curl_format_curl_off_t = "I32d";
                        @curl_format_curl_off_tu = "I32u";
                    break;

                    case "__int16":
                        @curl_format_curl_off_t = "I16d";
                        @curl_format_curl_off_tu = "I16u";
                    break;

                    default:
                        detect.fail "cannot find print format string for curl_off_t."
                        return false;
                }
            }
            detect.success(@curl_format_curl_off_t);

            detect.line "Checking formatting string directive for unsigned curl_off_t"
            detect.success(@curl_format_curl_off_tu);

            // Getting suffix
            @curl_suffix_curl_off_t = "unknown";
            @curl_suffix_curl_off_tu = "unknown";
            @DO_CURL_OFF_T_SUFFIX_CHECK() || return false;

            if(x_pull_headers) {
                for(var def,hdr in {
                    CURL_PULL_SYS_TYPES_H:  "sys/types.h",
                    CURL_PULL_STDINT_H:     "sys/stdint.h",
                    CURL_PULL_INTTYPES_H:   "inttypes.h"
                }) detect.header("c", hdr) && detect.define(def);
            }

            // Now define curl_off_t!
            for(var def,val in {
                CURL_TYPEOF_CURL_OFF_T:     @curl_typeof_curl_off_t,
                CURL_FORMAT_CURL_OFF_T:     @curl_format_curl_off_t,
                CURL_FORMAT_CURL_OFF_TU:    @curl_format_curl_off_tu,
                CURL_FORMAT_OFF_T:          @curl_format_curl_off_t,
                CURL_SIZEOF_CURL_OFF_T:     @curl_sizeof_curl_off_t,
                CURL_SUFFIX_CURL_OFF_T:     @curl_suffix_curl_off_t,
                CURL_SUFFIX_CURL_OFF_TU:    @curl_suffix_curl_off_tu
            }) detect.define(def, val);
        },
        DO_CURL_OFF_T_CHECK: function(
            /* $1 */ checkType
        ) {
            if(@curl_typeof_curl_off_t == "unknown") {
                var tmp_includes = "";
                var tmp_source = "";
                var tmp_fmt = "";
                switch(checkType) {
                    case "int64_t":
                        tmp_includes =
                        tmp_source ="char f@<:@@:>@ = PRId64;"
                        tmp_fmt = "PRId64"
                    break;
                }
            }
        },
        DO_CURL_OFF_T_SUFFIX_CHECK: function() {
            detect.line "Checking for constant suffix string for curl_off_t";
            var tst_suffixes;
            switch(@curl_typeof_curl_off_t) {
                case "long long":
                case "__longlong":
                case "__longlong_t":
                    tst_suffixes = "LL::";
                break;

                case "long":
                    tst_suffixes = "L::";
                break;

                case "int":
                    tst_suffixes = "::";
                break;

                case "__int64":
                case "int64_t":
                    tst_suffixes = "LL:i64::";
                break;

                case "__int32":
                case "int32_t":
                    tst_suffixes = "L:i32::";
                break;

                case "__int16":
                case "int16_t":
                    tst_suffixes = "L:i16::";
                break;

                default:
                    throw "Expected datatype: ${@curl_typeof_curl_off_t}"
            }

            for(var n,tmp_ssuf in tst_suffixes.split("::")) {
                if(@curl_suffix_curl_off_t == "unknown") {
                    var tmp_usuf;
                    switch(tmp_ssuf) {
                        case "i64":
                        case "i32":
                        case "i16":
                            tmp_usuf = "u${tmp_ssuf}";
                        break;
                        case "L":
                        case "LL":
                            tmp_usuf = "U${tmp_ssuf}";
                        break;
                        default:
                            tmp_usuf = "";
                    }
                    var built, spawned, exitCode, streams
                        = detect.tryRun([
                            detect.getDefinesString(),
                            @curl_includes_inttypes_src,
                            "typedef ${@curl_typeof_curl_off_t} new_t",
                            "int main(int argc, char** argv){        ",
                            "   new_t s1;                            ",
                            "   new_t s2;                            ",
                            "   s1 = -10${tmp_ssuf};                 ",
                            "   s2 =  20${tmp_ssuf};                 ",
                            "   if(s1 > s2)                          ",
                            "       return 1;                        ",
                            "}"
                        ].join("\n"), "CC");
                    if(built && spawned) {
                        if(exitCode == 1) {
                            @curl_suffix_curl_off_t = tmp_ssuf;
                            @curl_suffix_curl_off_tu = tmp_usuf;
                            break;
                        }
                    } else {
                        detect.fail "Failed to execute test."
                        return false;
                    }
                }
            }
            if(@curl_suffix_curl_off_t == "unknown") {
                detect.fail "cannot find constant suffix string for curl_off_t."
            } else {
                detect.success(@curl_suffix_curl_off_t)
                detect.line "Checking for constant suffix string for unsigned curl_off_t"
                detect.success(@curl_suffix_curl_off_tu)
                return true;
            }
        },
        CURL_CHECK_NEED_REENTRANT_SYSTEM: function() {
            var host_os = detect.os();
            @tmp_need_reentrant = false;
            if(wildcard.match("solaris*", host_os)) {
                @tmp_need_reentrant = true;
            }
        },
        CURL_CHECK_NEED_REENTRANT_ERRNO: function() {
            var compiled = detect.tryCompile([
                detect.getDefinesString(),
                "#include <errno.h> ",
                "int main(){        ",
                "   if(0 != errno)  ",
                "       return 1;   ",
                "}                  "
            ].join("\n"), "C");
            if(compiled) {
                @tmp_errno = true;
            } else {
                @tmp_errno = false;
            }
            if(@tmp_errno) {
                compiled = detect.tryCompile([
                    detect.getDefinesString(),
                    "#include <errno.h>     ",
                    "#ifdef errno           ",
                    "   int dummy=1;        ",
                    "#else                  ",
                    "   Force compile error ",
                    "#endif                 ",
                    "int main(){ return 0; }"
                ].join("\n"), "C");
                if(compiled) {
                    @tmp_errno = "errno_macro_defined";
                    compiled = detect.tryCompile([
                        detect.getDefinesString(),
                        "#define _REENTRANT         ",
                        "#include <errno.h>         ",
                        "#ifdef errno               ",
                        "   int dummy=1;            ",
                        "#else                      ",
                        "   force compilation error ",
                        "#endif                     ",
                        "int main(){ return 0; }    "
                    ].join("\n"), "C");
                    if(compiled) {
                        @tmp_errno = "errno_macro_needs_reentrant";
                        @tmp_need_reentrant = true;
                    }
                }
            }
        },
        CURL_CHECK_NEED_REENTRANT_FUNCTIONS_R: function() {
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GMTIME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_LOCALTIME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_STRERROR_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_STRTOK_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_INET_NTOA_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETHOSTBYADDR_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETHOSTBYNAME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETPROTOBYNAME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETSERVBYPORT_R();
            }
        },
        CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST: function(
            funct,      // Name of the function to look for.
            varName,    // Name of local variable to set function-specific knowledge to.
            generalVar, // Name of local variable to generally set to true.
            headers,    // List of headers to include.
        ) {
            var have_func = detect.func(funct);
            if(have_func) {
                var compiled = detect.tryCompile([
                    "#include <sys/types.h>     ",
                    "#include <time.h>          ",
                    "int main() {               ",
                    "   void* f;                ",
                    "   f = (void*)(${funct});  ",
                    "}                          "
                ]);
                if(compiled) {
                    this[varName] = "proto_declared";
                } else {
                    // I dont exactly understand AC_EGREP_CPP.
                    // So here is my take of testing if function is available,
                    // when _REENTRANT is defined.
                    // NOTE: Now I do. It checks if "cc -E" contains something.
                    // Huh, I could use String.indexOf! ...well, the stuff here works,
                    // so ill just note it for the future.
                    var headerString = @{
                        var parts = [];
                        for(var n,hdr in headers) {
                            parts[] = "#include <${hdr}>";
                        }
                        return parts.join("\n");
                    };
                    var built, spawned, exitCode, streams
                        = detect.tryRun([
                            "#define _REENTRANT                 ",
                            headerString,
                            "int main(int argc, char** argv) {  ",
                            "   if((void*)(${funct}) != NULL) { ",
                            "       return 1;                   ",
                            "   }                               ",
                            "}                                  "
                        ].join("\n"), "C");
                    if(built) {
                        if(spawned && exitCode == 1) {
                            this[varName] = "proto_needs_reentrant";
                            this[generalVar] = true;
                        }
                    }
                }
            }
        },
        CURL_CHECK_NEED_REENTRANT_GMTIME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gmtime_r",
                "tmp_gmtime_r",
                "tmp_need_reentrant",
                ["sys/types.h", "time.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_LOCALTIME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "localtime_r",
                "tmp_localtime_r",
                "tmp_need_reentrant",
                ["sys/types.h", "time.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_STRERROR_R: function(){
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "strerror_r",
                "tmp_strerror_r",
                "tmp_need_reentrant",
                ["sys/types.h", "string.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_STRTOK_R: function(){
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "strtok_r",
                "tmp_strtok_r",
                "tmp_need_reentrant",
                ["sys/types.h", "string.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_INET_NTOA_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "inet_ntoa_r",
                "tmp_inet_ntoa_r",
                "tmp_need_reentrant",
                [
                    "sys/types.h",
                    "sys/socket.h",
                    "netinet/in.h",
                    "arpa/inet.h"
                ]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETHOSTBYADDR_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gethostbyaddr_r",
                "tmp_gethostbyaddr_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETHOSTBYNAME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gethostbyname_r",
                "tmp_gethostbyname_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETPROTOBYNAME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "getprotobyname_r",
                "tmp_getprotobyname_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETSERVBYPORT_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "getservbyport_r",
                "tmp_getservbyport_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CONFIGURE_REENTRANT: function() {
            // Do a cache lookup
            var cacheKey = "need_reentrant";
            if(cacheKey in detect.cache) {
                var cacheVal = detect.cache.need_reentrant;
                detect.line "Checking if we use _REENTRANT";
                if(cacheVal == true || cacheVal == "true") {
                    detect.success "Yes."
                    return true;
                } else {
                    detect.fail "No."
                    return false;
                }
            }

            detect.line "Checking if _REENTRANT is already defined";
            @tmp_reentrant_initially_defined = null;
            @tmp_need_reentrant = null;
            var compiled = detect.tryCompile([
                detect.getDefinesString(),
                "#ifdef _REENTRANT              ",
                "      int dummy=1;             ",
                "#else                          ",
                "      force compilation error  ",
                "#endif                         ",
                "int main(){ return 0; }        "
            ].join("\n"), "CC");
            if(compiled) {
                detect.success "Yes."
                @tmp_reentrant_initially_defined = true;
            } else {
                detect.fail "No."
                @tmp_reentrant_initially_defined = false;
            }

            if(!@tmp_reentrant_initially_defined) {
                detect.line "Checking if _REENTRANT is actually needed"
                @CURL_CHECK_NEED_REENTRANT_SYSTEM();
                if(!@tmp_need_reentrant) {
                    @CURL_CHECK_NEED_REENTRANT_ERRNO();
                }
                if(!@tmp_need_reentrant) {
                    @CURL_CHECK_NEED_REENTRANT_FUNCTIONS_R();
                }
                if(@tmp_need_reentrant) {
                    detect.success "Yes."
                    detect.cache[cacheKey] = true;
                    return true;
                } else {
                    detect.fail "No."
                    detect.cache[cacheKey] = false;
                    return false;
                }
            } else {
                detect.cache[cacheKey] = true;
            }

            detect.line "Checking if _REENTRANT is onwards defined";
            if(
                @tmp_reentrant_initially_defined
                || @tmp_need_reentrant
            ) {
                @CURL_CONFIGURE_FROM_NOW_ON_WITH_REENTRANT();
                detect.success "Yes."
                return true;
            } else {
                detect.fail "No."
                return false;
            }
        },
        CURL_CONFIGURE_FROM_NOW_ON_WITH_REENTRANT: function() {
            var cacheKey = "__reentrant_called";
            if(cacheKey in this) return;
            detect.defineUnquoted("NEED_REENTRANT", 1);
            detect.settings.preSource += [
                "#ifndef _REENTRANT     ",
                "#  define _REENTRANT   ",
                "#endif                 ",
                "" // Additional newline
            ].join("\n");
            this[cacheKey] = true;
        },
        CURL_CHECK_AIX_ALL_SOURCE: function() {
            detect.line "Is this AIX we're building on?"
            if("IS_AIX" in detect.cache) {
                if(detect.cache.IS_AIX == "true" || detect.cache.IS_AIX == true) {
                    detect.success "Yes. (Cached)"
                    return true;
                } else {
                    detect.fail "Likely not. (Cached)";
                    return false;
                }
            }
            var built, spawned, exitCode, streams
                = detect.tryRun([
                    "int main(int argc, char** argv) {  ",
                    "   #ifdef _AIX                     ",
                    "       return 1;                   ",
                    "   #else                           ",
                    "       return 0;                   ",
                    "   #endif                          ",
                    "}                                  "
                ].join("\n"), "CC");
            if(built) {
                if(spawned && exitCode == 1) {
                    detect.success "Yes."
                    detect.define("_ALL_SOURCE");
                    detect.cache.IS_AIX = true;
                    return true;
                } else {
                    detect.fail "Likely not.";
                    detect.cache.IS_AIX = false;
                    return false;
                }
            }
        },
        CURL_INCLUDES_POLL: function() {
            @curl_includes_poll = [
                "/* includes start */       ",
                "#ifdef HAVE_SYS_TYPES_H    ",
                "#  include <sys/types.h>   ",
                "#endif                     ",
                "#ifdef HAVE_POLL_H         ",
                "#  include <poll.h>        ",
                "#endif                     ",
                "#ifdef HAVE_SYS_POLL_H     ",
                "#  include <sys/poll.h>    ",
                "#endif                     ",
                "/* includes end */         "
            ].join("\n");
            for(var n,hdr in [
                "sys/types.h",
                "poll.h",
                "sys/poll.h"
            ]) detect.header("c", hdr);
        },
        CURL_CONFIGURE_PULL_SYS_POLL: function() {
            @CURL_INCLUDES_POLL();
            @tst_poll_events_macro_defined = false;
            var compiled = detect.tryCompile([
                detect.settings.preSource,
                detect.getDefinesString(),
                @curl_includes_poll,
                "int main(int argv, char** argc) {          ",
                "   #if defined(events) || defined(revents) ",
                "       return 0;                           ",
                "   #else                                   ",
                "       force compilation error             ",
                "   #endif                                  ",
                "}                                          "
            ].join("\n"), "CC");
            @tst_poll_events_macro_defined = compiled;
            if(@tst_poll_events_macro_defined) {
                if(detect.header("c", "sys/poll.h")) {
                    detect.defineUnquoted("CURL_PULL_SYS_POLL_H",1);
                }
            }
        },

        // QUOTE
        // This first checks if the preprocessor _THREAD_SAFE
        // symbol is already defined. If it isn't currently
        // defined a set of checks are performed to verify
        // if its definition is required. Finally, if
        // _THREAD_SAFE is already defined or needed it takes
        // care of making adjustments necessary to ensure
        // that it is defined equally for further configure
        // tests and generated config file.
        // /QUOTE
        CURL_CONFIGURE_THREAD_SAFE: function() {
            var cacheKey = "curl_thread_safe_checked";
            if(cacheKey in detect.cache) {
                detect.line "Checking for cURL thread safety"
                if(detect.cache[cacheKey] == "true") {
                    detect.success "Already checked. (Cached)"
                    return true;
                } else {
                    detect.fail "Already checked, failed. (Cached)"
                    return false;
                }
            }

            detect.line "Checking if _THREAD_SAFE is already defined"
            var rt;
            var compiled = detect.tryCompile([
                "int main(int argc, char** argv) {  ",
                "   #ifdef _THREAD_SAFE             ",
                "       int dummy=1;                ",
                "   #else                           ",
                "       force compilation error     ",
                "   #endif                          ",
                "}                                  "
            ].join("\n"), "CC");
            if(compiled) {
                detect.success "Yes."
                @tmp_thread_safe_initially_defined = true;
                detect.cache[cacheKey] = true;
                rt = true;
            } else {
                detect.fail "No."
                @tmp_thread_safe_initially_defined = false;
            }

            if(!@tmp_thread_safe_initially_defined) {
                detect.line "Checking if _THREAD_SAFE is actually needed"
                @CURL_CHECK_NEED_THREAD_SAFE_SYSTEM();
                if(@tmp_need_thread_safe) {
                    detect.success "Yes."
                    rt = true;
                } else {
                    detect.fail "No."
                }
            }

            detect.line "Checking if _THREAD_SAFE is onwards defined"
            if(
                @tmp_thread_safe_initially_defined
                || @tmp_need_thread_safe
            ) {
                @CURL_CONFIGURE_FROM_NOW_ON_WITH_THREAD_SAFE();
                detect.success "Yes.";
            } else {
                detect.fail "No.";
            }

            return rt;
        },
        CURL_CHECK_NEED_THREAD_SAFE_SYSTEM: function() {
            var host_os = detect.os();
            if( // QUOTE aix 4.2 and older /QUOTE
                wildcard.match("aix[123].*", host_os)
                || wildcard.match("aix4.[012].*", host_os)
            ) {
                @tmp_need_thread_safe = false;
            } else if(wildcard.match("aix*", host_os)) {
                // AIX 4.3 and newer
                @tmp_need_thread_safe = true;
            } else {
                @tmp_need_thread_safe = false;
            }
        },
        CURL_CONFIGURE_FROM_NOW_ON_WITH_THREAD_SAFE: function() {
            var cacheKey = "__thread_safe_called";
            if(cacheKey in this) return;
            detect.settings.preSource += [
                "#ifndef _THREAD_SAFE   ",
                "#  define _THREAD_SAFE ",
                "#endif                 ",
                "", // Additional newline
            ].join("\n");
            this[cacheKey] = true;
        },

        // Compiler stuff.
        CURL_CHECK_COMPILER: function() {
            // Vars
            @compiler_id = "unknown";
            @compiler_num = 0;
            @flags_dbg_all = "unknown";
            @flags_dbg_yes = "unknown";
            @flags_dbg_off = "unknown";
            @flags_opt_all = "unknown";
            @flags_opt_yes = "unknown";
            @flags_opt_off = "unknown";
            @flags_prefer_cppflags = false;

            // Ok, seriously.
            // The chance of IceTea currently running on a platform
            // like HP-UX or such is TINY.
            // Hence, I'm gonna skip a bunch of checks here.
            // If you read this and have time to kill: Here is something you can do =)
            //
            // I just realized. I could copy some of these and use them for NativeCompiler instance!
            // Indeed, coding this is teaching me a lot as well.

            //@CURL_CHECK_COMPILER_DEC_C();
            //@CURL_CHECK_COMPILER_HPUX_C();
            //@CURL_CHECK_COMPILER_IBM_C();
            //@CURL_CHECK_COMPILER_INTEL_C();
            @CURL_CHECK_COMPILER_CLANG();
            @CURL_CHECK_COMPILER_GNU_C();
            //@CURL_CHECK_COMPILER_LCC();
            //@CURL_CHECK_COMPILER_SGI_MIPSPRO_C();
            //@CURL_CHECK_COMPILER_SGI_MIPS_C();
            //@CURL_CHECK_COMPILER_SUNPRO_C();
            //@CURL_CHECK_COMPILER_TINY_C();
            //@CURL_CHECK_COMPILER_WATCOM_C();

            if(@compiler_id == "unknown") {
                print([
                    // QUOTE
                    "***                                                                        ",
                    "*** Warning: This configure script does not have information about the     ",
                    "*** compiler you are using, relative to the flags required to enable or    ",
                    "*** disable generation of debug info, optimization options or warnings.    ",
                    "***                                                                        ",
                    "*** Whatever settings are present in CFLAGS will be used for this run.     ",
                    "***                                                                        ",
                    "*** If you wish to help the cURL project to better support your compiler   ",
                    "*** you can report this and the required info on the libcurl development   ",
                    "*** mailing list: https://cool.haxx.se/mailman/listinfo/curl-library/      ",
                    "***                                                                        ",
                    // /QUOTE
                    "*** PLEASE NOTE: The above text came from the original Autotools based     ",
                    "*** build process. IceTea WILL behave differently. In case of an issue that",
                    "*** you think is related to IceTea, please raise an issue on Github at     ",
                    "*** https://github.com/IngwiePhoenix/IceTea instead!                       ",
                    "*** cURL is not related to IceTea and vice versa. I just built this script ",
                    "*** for my own purpose. But making it better and offering it as an         ",
                    "*** alternative way of building libcURL, might be awesome! :)              ",
                    "***                                                                        "
                ].join("\n"));
            }
        },
        CURL_CHECK_COMPILER_GNU_C: function() {
            detect.line "Checking if compiler is GNU C\n";
            if(detect.macro("__GNUC__") && @compiler_id == "unknown") {
                print detect.out;
                detect.success "GNU C Compiler found."
                @compiler_id = "GNU_C";
                var gccver, gccvhi, gccvlo;
                var invoke = function(args) {
                    var spawned, exitCode, streams
                        = $("${@detect.toolCache.CC} ${args}");
                    if(spawned && exitCode == 0) {
                        return streams[1].trim();
                    } else {
                        return false;
                    }
                }
                gccver = invoke("-dumpversion");
                gccvhi = gccver.split(".")[0];
                gccvlo = gccver.split(".")[1];
                @compiler_num = (
                    ( toNumber(gccvhi) * 100 )
                    + toNumber(gccvlo)
                );
                @flags_dbg_all = [
                    "-g", "-g0", "-g1", "-g2", "-g3",
                    "-ggdb", "-gstabs", "-gstabs+",
                    "-gcoff", "-gxcoff", "-gdwarf-2",
                    "-gvms"
                ].join(" ");
                @flags_dbg_yes = "-g";
                @flags_dbg_off = "";
                @flags_opt_all = "-O -O0 -O1 -O2 -O3 -Os";
                @flags_opt_yes = "-O2";
                @flags_opt_off = "-O0";
            } else {
                print detect.out;
                detect.fail "GNU C Compiler not found."
            }
        },
        CURL_CHECK_COMPILER_CLANG: function() {
            @CURL_CHECK_COMPILER_GNU_C();
            detect.line "Checking if compiler is clang\n"
            if(detect.macro("__clang__")) {
                print detect.out
                detect.success "Clang found.";
                var invoke = function(args) {
                    var spawned, exitCode, streams
                        = $("${@detect.toolCache.CC} ${args}");
                    if(spawned && exitCode == 0) {
                        return streams[1].trim();
                    } else {
                        return false;
                    }
                }
                var clangver, clangvhi, clangvlo;
                @compiler_id = "CLANG"
                clangver = invoke("-dumpversion")
                clangvhi = clangver.split(".")[0];
                clangvlo = clangver.split(".")[1];
                @compiler_num = (
                    ( toNumber(clangvhi) * 100 )
                    + toNumber(clangvlo)
                );
                @flags_dbg_all = [
                    "-g", "-g0", "-g1", "-g2", "-g3",
                    "-ggdb", "-gstabs", "-gstabs+",
                    "-gcoff", "-gxcoff", "-gdwarf-2",
                    "-gvms"
                ].join(" ");
                @flags_dbg_yes="-g"
                @flags_dbg_off=""
                @flags_opt_all="-O -O0 -O1 -O2 -Os -O3 -O4"
                @flags_opt_yes="-Os"
                @flags_opt_off="-O0"
            }
        },
        CURL_SET_COMPILER_BASIC_OPTS: function() {
            if(@compiler_id != "unknown") {
                if(@compiler_id == "GNU_C" || @compiler_id == "CLANG") {
                    @CURL_CONVERT_INCLUDE_TO_ISYSTEM();
                }
                var tmp_cflags = [];
                var tmp_cppflags = [];
                switch(@compiler_id) {
                    case "CLANG":
                        // QUOTE
                        // Disable warnings for unused arguments, otherwise clang will
                        // warn about compile-time arguments used during link-time, like
                        // -O and -g and -pedantic.
                        // /QUOTE
                        tmp_cflags[] = "-Qunused-arguments";
                    break;
                    case "GNU_C":
                        // QUOTE: Select strict ANSI C compiler mode
                        tmp_cflags[] = "-std1"
                        // QUOTE: Turn off optimizer ANSI C aliasing rules
                        tmp_cflags[] = "-noansi_alias"
                        // QUOTE: Generate warnings for missing function prototypes
                        tmp_cflags[] = "-warnprotos"
                        // QUOTE: Change some warnings into fatal errors
                        tmp_cflags[] = "-msg_fatal toofewargs,toomanyargs"
                    break;
                    // Skipping HPUX, INTEL, WATCOM, ...
                }

                detect.line "Checking if compiler accepts some basic options"
                var flags = [] + tmp_cppflags + tmp_cflags;
                if(detect.tryCompilerFlag(flags, "CC")) {
                    detect.success "Working. Added: ${flags.join(' ')}"
                    // Since we are one level too deep, we need to hack into it.
                    target("curl").settings.CC.flags += flags;
                    return true;
                } else {
                    detect.fail "No. Options rejected: ${flags}"
                    return false;
                }
            }
        },
        CURL_TEST_COMPILER_OPTIONS: function(cacheKey, flags, verb) {
            flags = __.isArray(flags)? flags : [flags];
            if(cacheKey in this) { return this[cacheKey]; }
            detect.line "Checking if compiler accepts ${verb} options...\n";
            if(detect.tryCompilerFlag(flags, "CC")) {
                print detect.out;
                detect.success "compiler options added: ${flags}";
                IceTea.__targets.curl.settings.CC.flags += flags;
                this[cacheKey] = true;
            } else {
                print detect.out;
                detect.fail "Rejected: ${@flags_dbg_yes}"
                this[cacheKey] = false;
            }
        },
        CURL_SET_COMPILER_DEBUG_OPTS: function() {
            if(@compiler_id != "undefined") {
                if(@CURL_DEBUG) {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_debug_on_flags",
                        @flags_dbg_yes,
                        "debug enabling"
                    );
                } else {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_debug_off_flags",
                        @flags_dbg_off,
                        "debug disabling"
                    );
                }
            }
        },
        CURL_SET_COMPILER_OPTIMIZE_OPTS: function() {
            if(@compiler_id != "unknown") {
                // TODO: Honour the assume_yes/assume_no things.
                // This would enable us to actually derive settings off
                // the assumptions that the beginning of configure() had made.
                // For now, we just accept a TRUE or FALSE to the table :)
                if(@CURL_OPTIMIZE) {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_optimize_on_flags",
                        @flags_opt_yes,
                        "optimization enabling"
                    );
                } else {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_optimize_off_flags",
                        @flags_opt_off,
                        "optimization disabling"
                    );
                }
            }
        },
        CURL_SET_COMPILER_WARNING_OPTS: function() {
            // FIXME: Use IceTea's warnings, instead.
            // In fact, we should possibly make this an API: detect.warning(...)
            // Would allow for the Compiler objects to actually be used for testing.
            // Therefore: FIXME: Better CompilerObject integration!
            if(@compiler_id != "unknown") {
                var cflags = [];
                var cppflags = [];
                switch(@compiler_id) {
                    case "CLANG":
                        cflags = [
                            "-pedantic",
                            "-Wall",
                            "-Wextra",
                            "-Wpointer-arith",
                            "-Wwrite-strings",
                            "-Wshadow",
                            "-Winline",
                            "-Wnested-externs",
                            "-Wmissing-declarations",
                            "-Wmissing-prototypes",
                            "-Wno-long-long",
                            "-Wfloat-equal",
                            "-Wno-multichar",
                            "-Wsign-compare",
                            "-Wundef",
                            "-Wno-format-nonliteral",
                            "-Wendif-labels",
                            "-Wstrict-prototypes",
                            "-Wdeclaration-after-statement",
                            "-Wcast-align",
                            "-Wno-system-headers",
                            "-Wshorten-64-to-32"
                        ];
                        if(@compiler_num > 101) {
                            // Clang 1.1 or higher. So, that's what compiler_num is for.
                            cflags[] = "-Wunused";
                        }
                    break;

                    case "GNU_C":
                        // TODO: cross-compile check. I doubt IceTea actually does XC yet...at least not very good.
                        if(@compiler_num > 300) {
                            cflags[] = "-pedantic";
                        }
                        cflags += ["-Wall","-W"];
                        if(@compiler_num > 104) {
                            cflags += ["-Wpointer-arith","-Wwrite-strings"];
                            // TODO: Cross-compile check.
                            if(@compiler_num > 300) {
                                cflags += ["-Wunused","-Wshadow"];
                            }
                        }
                        if(@compiler_num > 207) {
                            cflags += ["-Winline","-Wnested-externs"];
                            if(@compiler_num > 300) {
                                cflags[] = "-Wmissing-declarations";
                                cflags[] = "-Wmissing-prototypes";
                            }
                        }
                        if(@compiler_num > 295) {
                            cflags[] = "-Wno-long-long";
                        }
                        if(@compiler_num > 296) {
                            cflags += [
                                "-Wfloat-equal",
                                "-Wno-multichar",
                                "-Wsign-compare",
                                "-Wundef"
                            ];
                        }
                        if(@compiler_num > 297) {
                            cflags[] = "-Wno-format-nonliteral";
                        }
                        if(@compiler_num > 300) {
                            // I encountered a tiny GCC rent. Heh :)
                        }
                        if(@compiler_num > 303) {
                            cflags += ["-Wendif-labels","-Wstrict-prototypes"];
                        }
                        if(@compiler_num > 304) {
                            cflags[] = "-Wdeclaration-after-statement";
                        }
                        if(@compiler_num > 400) {
                            cflags[] = "-Wstrict-aliasing=3";
                        }
                        if(@compiler_num > 402) {
                            cflags[] = "-Wcast-align";
                        }
                        if(@compiler_num > 403) {
                            cflags += [
                                "-Wtype-limits",
                                "-Wold-style-declaration",
                                "-Wmissing-parameter-type",
                                "-Wempty-body",
                                "-Wclobbered",
                                "-Wignored-qualifiers",
                                "-Wconversion",
                                "-Wno-sign-conversion",
                                "-Wvla"
                            ];
                        }
                        if(@compiler_num > 405) {
                            if(detect.macro("__WIN32")) {
                                cflags[] = "-Wno-pedantic-ms-format";
                            }
                        }
                        // No warnings on isystem headers
                        if(@compiler_num > 300) {
                            cflags[] = "-Wno-system-headers";
                        } else {
                            // TODO: Cross-Compile stuff
                        }
                    break;
                }
                if(#cflags > 0 || #cppflags > 0) {
                    detect.line "Checking if compiler accepts options\n";
                    var flags = [] cflags + cppflags;
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_warnings_flags",
                        flags,
                        "strict warning"
                    );
                }
            }
        },
        CURL_CHECK_COMPILER_HALT_ON_ERROR: function() {
            // TODO: Make a call-guard, damnit. :I
            // I.e.: Abuse __get@...() to auto-guard calls.
            var cacheKey = "__called_halt_on_error";
            if(cacheKey in this) return this[cacheKey];

            //detect.line "Checking if compiler halts on compilation errors";
            // Ok seriously. How do I implement this? Big, fat, TODO.
        },
        CURL_CHECK_COMPILER_ARRAY_SIZE_NEGATIVE: function() {
            // QUOTE
            // Verifies if the compiler actually halts after the
            // compilation phase without generating any object
            // code file, when the source code tries to define a
            // type for a constant array with negative dimension.
            // /QUOTE

            // Callguard.
            var cacheKey = "__array_size_negative";
            if(cacheKey in this) return true; // Only possible solution. else exit()s immediately.

            detect.line "Checking if compiler halts on negative sized arrays"
            var src = [
                "typedef char bad_t[sizeof(char) == sizeof(int) ? -1 : -1 ];",
                "int main() {",
                "   bad_t dummy;",
                "}"
            ].join("\n");
            if(! detect.tryCompile(src, "CC")) {
                detect.success "Yes (hopefuly?)"
                this[cacheKey] = true;
                return true;
            } else {
                detect.fail "I guess no."
                detect.abort "compiler does not halt on negative sized arrays."
                return false;
            }
        },
        CURL_CHECK_COMPILER_PROTOTYPE_MISMATCH: function() {
            var cacheKey = "__proto_mismatch_called";
            if(cacheKey in this) return true;
            detect.line "Checking if compiler halts on function prototype mismatch"
            var src = [
                "#include <stdlib.h>    ",
                "int rand(int n);       ",
                "int rand(int n) {      ",
                "   if(n)               ",
                "       return ++n;     ",
                "   else                ",
                "       return n;       ",
                "}                      ",
                "int main() {           ",
                "   int i[2]={0,0};     ",
                "   int j = rand(i[0]); ",
                "   if(j) return j;     ",
                "}                      "
            ].join("\n");
            if(! detect.tryCompile(src, "CC")) {
                detect.success "Yes."
                this[cacheKey] = true;
                return true;
            } else {
                detect.fail "No."
                detect.abort "compiler does not halt on function prototype mismatch."
                return false;
            }
        },
        CURL_CHECK_COMPILER_SYMBOL_HIDING: function() {
            var cacheName = "__symbol_hiding_called";
            if(cacheName in this) return this[cacheName];
            detect.line "Checking if compiler supports hiding library internal symbols"
            var supports_symbol_hiding = false;
            var symbol_hiding_CFLAGS = "";
            var symbol_hiding_EXTERN = "";
            var tmp_CFLAGS = "";
            var tmp_EXTERN = "";
            switch(@compiler_id) {
                case "CLANG":
                    // Easy. Use -fvisibility=...
                    tmp_EXTERN ="__attribute__ ((__visibility__ (\"default\")))";
                    tmp_CFLAGS = "-fvisibility=hidden";
                    supports_symbol_hiding = true;
                break;
                case "GNU_C":
                    if(@compiler_num > 304) {
                        var spawned, exitCode, streams
                            = $("${detect.toolCache.CC} --help --verbose");
                        var out;
                        if(exitCode == 0) {
                            if(#streams[1] > #streams[2]) {
                                out = streams[1];
                            } else {
                                out = streams[2];
                            }
                        } else {
                            detect.abort "The program exited with non-zero exit code: ${exitCode}"
                            return false;
                        }
                        if(out.indexOf("-fvisibility=") != -1) {
                            tmp_EXTERN = "__attribute__ ((__visibility__ (\"default\")))";
                            tmp_CFLAGS = "-fvisibility=hidden";
                            supports_symbol_hiding = true;
                        }
                    }
                break;
                // Skipping other compilers...
            }
            if(supports_symbol_hiding) {
                var src = [
                    "${tmp_extern} char *dummy(char *buff); ",
                    "char *dummy(char *buff) {              ",
                    "   if(buff)                            ",
                    "       return ++buff;                  ",
                    "   else                                ",
                    "       return buff;                    ",
                    "}                                      ",
                    "int main(ing argc, char** argv) {      ",
                    "   char b[16];                         ",
                    "   char *r = dummy(&b[0]);             ",
                    "   if(r) return (int)*r;               ",
                    "}                                      "
                ].join("\n");
                if(detect.tryCompile(src, "CC", tmp_CFLAGS)) {
                    supports_symbol_hiding = true;
                } else {
                    supports_symbol_hiding = false;
                }
            }
            if(supports_symbol_hiding) {
                detect.success "Yes."
                this[cacheKey] = true;
                return true;
            } else {
                detect.success "No."
                this[cacheKey] = false;
                return false;
            }
        },
        CURL_CHECK_CURLDEBUG: function() {
            // TODO: This function, right here.
            //var cacheKey = "__called_curldebug";
            //if(cacheKey in this) return this[cacheKey];
            var supports_curldebug = "unknown";
            if(@CURL_CURLDEBUG) {
                // Skip shared build checks...
                // Skip static build check...
            }
            // Skipped some test I didn't even understand...
            // detect.line "Checking if curl debug memory tracking can be enabled";
            if(@CURL_CURLDEBUG) {
                IceTea.__targets.curl.settings.CC.defines[] = "CURLDEBUG";
            }
            if(@CURL_DEBUG) {
                IceTea.__targets.curl.settings.CC.defines[] = "DEBUGBUILD";
            }
        },
        CURL_CHECK_FUNC_CLOCK_GETTIME_MONOTONIC: function() {
            var cacheKey = "__monotronic_gettime_func_called";
            if(cacheKey in this) return this[cacheKey];

            for(var x,hdr in [
                "sys/types.h",
                "sys/time.h",
                "time.h"
            ]) detect.header("c", hdr);

            detect.line "Checking for monotonic clock_gettime";
            if(@CURL_RT == false) {
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "   struct timespec ts;     ",
                    "   (void)clock_gettime(    ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   );                      ",
                    "}                          "
                ].join("\n"), "CC")) {
                    detect.success "Yes"
                    @ac_cv_func_clock_gettime = true;
                    this[cacheKey] = true;
                } else {
                    detect.fail "No"
                    @ac_cv_func_clock_gettime = false;
                    this[cacheKey] = false;
                }
            }
        },
        CURL_CHECK_LIBS_CLOCK_GETTIME_MONOTONIC: function() {
            @CURL_CHECK_FUNC_CLOCK_GETTIME_MONOTONIC();
            var cacheKey = "__monotronic_gettime_libs_called";
            if(cacheKey in this) return this[cacheKey];

            detect.line "Checking for clock_gettime in libraries"
            var curl_cv_gclk_LIBS = false;
            for(var n,x_xlibs in ['','-lrt','-lposix4']) {
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "    struct timespec ts;    ",
                    "    (void)clock_gettime(   ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   );                      ",
                    "}                          "
                ].join("\n"), "CC")) {
                    curl_cv_gclk_LIBS = x_xlibs;
                    break;
                }
            }
            if(curl_cv_gclk_LIBS == false) {
                detect.fail "cannot find clock_gettime"
                detect.warn "HAVE_CLOCK_GETTIME_MONOTONIC will not be defined"
                @ac_cv_func_clock_gettime = false;
                this[cacheKey] = false;
                return false;
            } else if(curl_cv_gclk_LIBS == "") {
                detect.success "no additional lib required"
                @ac_cv_func_clock_gettime = true;
            } else {
                @settings.LINK.libraries[]
                    = curl_cv_gclk_LIBS.sub(2);
                detect.success curl_cv_gclk_LIBS;
                @ac_cv_func_clock_gettime = true;
            }
            // Skipping cross-compile check...
            if(@ac_cv_func_clock_gettime) {
                detect.line "Checking if monotonic clock_gettime works"
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_STDLIB_H       ",
                    "#include <stdlib.h>        ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "   struct timespec ts;     ",
                    "   if (0 == clock_gettime( ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   ))                      ",
                    "       exit(0);            ",
                    "    else                   ",
                    "       exit(1);            ",
                    "}                          "
                ].join("\n"), "CC")) {
                    detect.success "Yes";
                    this[cacheKey] = true;
                } else {
                    detect.fail "No";
                    detect.warn "HAVE_CLOCK_GETTIME_MONOTONIC will not be defined"
                    @ac_cv_func_clock_gettime = false;
                    this[cacheKey] = false;
                }
                if(@ac_cv_func_clock_gettime) {
                    detect.define("HAVE_CLOCK_GETTIME_MONOTONIC", 1);
                }
                return this[cacheKey];
            }
        },
        CURL_CONFIGURE_GSSAPI: function() {
            @GSSAPI_ROOT = "/usr";
            if(
                detect.isWith("curl-gssapi-libs")
                || detect.isWith("curl-gssapi-includes")
                || detect.isWith("curl-gssapi")
            ) {
                @CURL_GSSAPI = true;

                var isWith, gssapiDir = detect.isWith("curl-gssapi");
                if(isWith && gssapiDir != "") {
                    @GSSAPI_ROOT = gssapiDir;
                }
            }
            @KRB5CONFIG = "${@GSSAPI_ROOT}/bin/krb5-config";
            detect.line "Checking if GSS-API support is requested"
            if(@CURL_GSSAPI) {
                detect.success "Yes"
                var withDirs, incDirs = detect.isWith("curl-gssapi-includes");
                var withLibs, libDirs = detect.isWith("curl-gssapi-libs");
                // Following is a copy of an autoconf check:
                // QUOTE
                // if test -z "$GSSAPI_INCS"; then
                //      if test -n "$host_alias" -a -f "$GSSAPI_ROOT/bin/$host_alias-krb5-config"; then
                //          GSSAPI_INCS=`$GSSAPI_ROOT/bin/$host_alias-krb5-config --cflags gssapi`
                //      elif test -f "$KRB5CONFIG"; then
                //          GSSAPI_INCS=`$KRB5CONFIG --cflags gssapi`
                //      elif test "$GSSAPI_ROOT" != "yes"; then
                //          GSSAPI_INCS="-I$GSSAPI_ROOT/include"
                //      fi
                // fi
                // /QUOTE
                // Unless I know how to obtain $host_alias, I won't be making this check. completely.
                if(!withDirs) {
                    var dirFlags;
                    /*var aliasedKrbConf = pfs.join(
                        @GSSAPI_ROOT,
                        "bin",
                        "${host_apias}-krb5-config"
                    );
                    // ... = -n $host_alias -a -> I dont know these, yet.
                    if(... && pfs.isFile(aliasedKrbConf)) {
                        var spawned, exitCode, streams
                            = $("${aliasedKrbConf} --cflags gssapi");
                        if(spawned && exitCode == 0) {
                            // Since we're exporting the .native object into exports,
                            // we'd better ensure that captured CFlags are added!
                            // After all, they might be used _not just_ in libcurl,
                            // but also on dependant targets.
                            target("curl").settings.native.flags[] = streams[1].trim();
                        }
                    } else*/ if(pfs.isFile(@KRB5CONFIG)) {
                        var spawned, exitCode, streams
                            = $("${@KRB5CONFIG} --cflags gssapi");
                        if(spawned && exitCode == 0) {
                            dirFlags = streams[1].trim();
                        }
                    } else {
                        // Well, let's just hope this works!
                        // @see: http://xkcd.com/292/
                        dirFlags = "-I" .. [
                            @GSSAPI_ROOT,
                            "include"
                        ].join(sys.dirSep);
                    }
                    if(detect.header("c", "gss.h", dirFlags)) {
                        // Regular GSS-API
                        detect.define("HAVE_GSSGNU", 1);
                        @not_mit = false;
                    } else if(detect.header("c", "gss/gss.h", dirFlags)) {
                        @not_mit = true;
                    } else if(
                        detect.header("c", "gssapi/gssapi_generic.h", dirFlags)
                        && detect.header("c", "gssapi/gssapi_krb5.h", dirflags)
                    ) {
                        @not_mit = true;
                    }
                    if(@not_mit) {
                        // Not MIT, so we look for Heimdal.
                        if(detect.header("c","gssapi.h", dirFlags)) {
                            detect.define("HAVE_GSSHEIMDAL", 1);
                        } else {
                            @CURL_GSSAPI = false;
                            detect.warn "disabling GSS-API support since no header files were found"
                        }
                    } else {
                        // MIT!
                        detect.define("HAVE_GSSMIT", 1);
                        detect.line "Checking if GSS-API headers declare GSS_C_NT_HOSTBASED_SERVICE"
                        if(detect.tryCompile([
                            "#include <gssapi/gssapi.h>         ",
                            "#include <gssapi/gssapi_generic.h> ",
                            "#include <gssapi/gssapi_krb5.h>    ",
                            "int main() {                       ",
                            "   gss_import_name(                ",
                            "       (OM_uint32 *)0,             ",
                            "       (gss_buffer_t)0,            ",
                            "       GSS_C_NT_HOSTBASED_SERVICE, ",
                            "       (gss_name_t *)0             ",
                            "   );                              ",
                            "}                                  "
                        ].join("\n"), "CC")) {
                            detect.success "Yes"
                        } else {
                            detect.fail "No"
                            detect.define("HAVE_OLD_GSSMIT", 1);
                        }
                    }
                }
            } else {
                detect.fail "No."
            }
            if(@CURL_GSSAPI) {
                detect.define("HAVE_GSSAPI", 1);
                @curl_gss_msg = "enabled (MIT Kerberos/Heimdal)";
                // Oops? Did I miss something?
                if(@gnu_gss) {
                    @curl_gss_msg = "enabled (GNU GSS)";
                    target("curl").settings.LINK.libraryDirs[] = @GSSAPI_LIB_DIR;
                    target("curl").settings.LINK.libraries[] = "gss";
                } else if(!@GSSAPI_LIB_DIR) {
                    // Ugh. This thing I need to do..
                    var host = detect.host();
                    if(wildcard.match("*-*-darwin*", host)) {
                        target("curl").settings.LINK.libraries += [
                            "gssapi_krb5",
                            "resolv"
                        ];
                    } else {
                        // var host_alias = ...;
                        // if(-n "$host_alias" -a -f "$GSSAPI_ROOT/bin/$host_alias-krb5-config")
                        // QUOTE
                        //      krb5-config doesn't have --libs-only-L or similar, put everything
                        //      into LIBS
                        //      gss_libs=`$GSSAPI_ROOT/bin/$host_alias-krb5-config --libs gssapi`
                        //      LIBS="$gss_libs $LIBS"
                        // /QUOTE
                        // } else
                        if(pfs.isFile(@KRB5CONFIG)) {
                            target("curl").settings.LINK.flags[] = system(
                                "${@KRB5CONFIG} --libs gssapi"
                            ) || "";
                        }
                        else {
                            var host = detect.host();
                            if(wilcard.match("*-hp-hpux*", host)) {
                                target("curl").settings.LINK.libraries[] = "gss";
                            } else {
                                target("curl").settings.LINK.libraries[] = "gssapi";
                            }
                        }
                    }
                }
            }
        }
    },
    init: function() {
        cli.group "cURL library";
        // [En|Dis]able
        var eda = function(name, desc) {
            detect.enable("curl-${name}", "Enable cURL ${desc}");
            detect.disable("curl-${name}", "Disable cURL ${desc}");
        }
        for(var name, desc in {
            // Debug
            debug:          "debug options",
            // Optimization
            optimize:       "optimization options",
            // Warnings
            warnings:       "warnings",
            werror:         "to treat all warnings as errors",
            // curldebug. Im guessing it's the debugging infra
            // within cURL itself. (extra logging, etc)
            curldebug:      "internal debug functionalities",
            // Symbol hiding
            "hide-symbols": "library to hide it's internal symbols",
            // C-Ares support?
            // FIXME: c-ares for IceTea. PhoenixEngine has it, move it in.
            // Use the + operator and IceTea.hasTarget - for instance.
            cares:          "to use c-ares for DNS lookups",
            // librt
            rt:             "dependance on librt",
        }) eda(name, desc);
        for(var n,proto in @CURL.protocols) {
            eda(proto, "${name} protocol support");
        }
        // Libraries.
        // Once again: Scripting languages are hella powerful.
        for(var _,lib in @CURL.sslLibs) {
            detect.with(
                "curl-${lib}",
                "SSL: Support ${lib} in cURL"
            );
        }
        for(var _,lib in @CURL.windowsLibs) {
            detect.with(
                "curl-${lib}",
                "Windows: Support ${lib} in cURL"
            );
        }
        for(var _,lib in @CURL.otherLibs) {
            detect.with(
                "curl-${lib}",
                "Enable building cURL with ${lib}"
            );
        }
        for(var _,word in @CURL.genericEnables) {
            detect.enable("curl-${word}", "Enable: ${word}")
        }

        detect.with(
            "curl-lber-lib",
            "Specify path to lber library"
        );

        detect.with(
            "curl-gssapi-includes",
            "Specify GSSAPI includes for cURL to use.",
            "<Dir>"
        );
        detect.with(
            "curl-gssapi-libs",
            "Specify GSSAPI libs for cURL to use.",
            "<Dir>"
        );
        detect.with(
            "curl-gssapi",
            "Specify folder where to look for GSS-API stuff",
            "<Dir>"
        );

        // Autoconf-like
        autoconf.AC_SYS_LARGEFILE_INIT();
    },
    configure: function() {
        // Save current pre-source.
        var __DCT_SETTINGS = detect.settings;

        // FIXME's:
        // - include/curl/curlbuild.h.in : Make an IceTea variant.

        // Almost like a try-catch, but simpler.
        // We sandbox execution so that we can
        // reset the preSource properly and do any neccessary
        // pre/post manipulation without corrupting it.
        // Just in case.
        var ConfigureReturn = @{
            // # Check options
            // FIXME: I could probably simplify this by a lot. Thats for later tho.
            // ## Debug
            @CURL.CURL_DEBUG = null;
            if(detect.enabled("curl-debug") && !detect.disabled("curl-debug")) {
                @CURL.CURL_DEBUG = true;
            } else if(!detect.enabled("curl-debug") && detect.disabled("curl-debug")) {
                @CURL.CURL_DEBUG = false;
            } else {
                @CURL.CURL_DEBUG = false;
            }
            // ## Optimization
            @CURL.CURL_OPTIMIZE = null;
            if(detect.enabled("curl-optimize") && !detect.disabled("curl-optimize")) {
                @CURL.CURL_OPTIMIZE = true;
            } else if(!detect.enabled("curl-optimize") && detect.disabled("curl-optimize")) {
                @CURL.CURL_OPTIMIZE = false;
            } else {
                // QUOTE
                // configure's optimize option not specified. Initially we will
                // handle this as a a request contrary to configure's setting
                // for --enable-debug. IOW, initially, for debug-enabled builds
                // this will be handled as a request to disable optimizations if
                // possible, and for debug-disabled builds this will be handled
                // initially as a request to enable optimizations if possible.
                // Finally, if the compiler is known and CFLAGS and CPPFLAGS do
                // not have any optimizer flag the request will be honored, in
                // any other case the request can not be honored.
                // IOW, existing optimizer flags defined in CFLAGS or CPPFLAGS
                // will always take precedence over any initial assumption.
                // /QUOTE
                @CURL.CURL_OPTIMIZE = (@CURL.CURL_DEBUG == true ? false : true);
            }
            // ## Warnings
            @CURL.CURL_WARNINGS = null;
            if(detect.enabled("curl-warnings") && !detect.disabled("curl-warnings")) {
                @CURL.CURL_WARNINGS = true;
            } else if(!detect.enabled("curl-warnings") && detect.disabled("curl-warnings")) {
                @CURL.CURL_WARNINGS = false;
            } else {
                @CURL.CURL_WARNINGS = @CURL.CURL_DEBUG;
            }
            // ## -Werror
            @CURL.CURL_WERROR = null;
            if(detect.enabled("curl-werror")) {
                @settings.native.allErrors = true;
                @CURL.CURL_WERROR = true;
            } else {
                @CURL.CURL_WERROR = false;
            }
            // ## CurlDebug
            @CURL.CURL_CURLDEBUG = null;
            if(detect.enabled("curl-curldebug") && !detect.disabled("curl-curldebug")) {
                @CURL.CURL_CURLDEBUG = true;
            } else if(!detect.enabled("curl-curldebug") && detect.disabled("curl-curldebug")) {
                @CURL.CURL_CURLDEBUG = false;
            } else {
                @CURL.CURL_CURLDEBUG = @CURL.CURL_DEBUG;
            }
            // ## Symbol hiding
            @CURL.CURL_HIDE_SYMBOLS = null;
            if(detect.enabled("curl-hide-symbols") && !detect.disabled("curl-hide-symbols")) {
                @CURL.CURL_HIDE_SYMBOLS = true;
            } else if(!detect.enabled("curl-hide-symbols") && detect.disabled("curl-hide-symbols")) {
                @CURL.CURL_HIDE_SYMBOLS = false;
            } else {
                @CURL.CURL_HIDE_SYMBOLS = true;
            }
            // ## C-Ares
            @CURL.CURL_CARES = null;
            // FIXME: IceTea support, custom path/prefix?
            if(detect.enabled("curl-cares") && !detect.disabled("curl-cares")) {
                @CURL.CURL_CARES = true;
                if(detect.lib("cares")) {
                    @settings.LINK.libraries[] = "cares";
                } else if(detect.lib("c-ares")) {
                    @settings.LINK.libraries[] = "c-ares";
                }
            } else if(!detect.enabled("curl-cares") && detect.disabled("curl-cares")) {
                @CURL.CURL_CARES = false;
            } else {
                @CURL.CURL_CARES = false;
            }
            // ## (lib)rt
            // I know, they do a reverse check.
            // But...no. Not now, later.
            @CURL.CURL_NO_RT = null;
            if(detect.disabled("curl-rt")) {
                @CURL.CURL_NO_RT = true;
            }

            // # Path separator check.
            // Im going to go the easyway out.
            @CURL.CURL_PATHSEP = sys.pathSep;

            // # Storing the configure options.
            // ... actually, not possible with IceTea. Good to know.
            @CURL.CURL_CONFIGURE_OPTIONS = "\"\"";
            detect.define("CONFIGURE_OPTIONS", @CURL.CURL_CONFIGURE_OPTIONS);

            // # Tools
            var CURL_TOOLS = {
                // NO. MORE. We have SLRE!
                // Actually I think I can trash this whole section now. :o
                // GREP: "grep",
                // SED: "sed",
                // EGREP: "egrep",

                // Hm. These tools could be problematic on other platforms.
                // So, ill just comment them out for now.
                //AR: "ar"
            }
            for(var define,tool in CURL_TOOLS) {
                var toolValue = detect.tool(tool);
                if(toolValue == "") {
                    detect.abort "${tool} is highly required!";
                    return false;
                }
                detect.define(define, toolValue);
            }

            // # curlbuild.h
            // Remove an existing one, if it exists.
            var curlbuild_h = pfs.join(CURL_SOURCEDIR, "include/curl/curlbuild.h")
            if(pfs.isFile(curlbuild_h)) {
                pfs.delete(curlbuild_h);
            } else if(pfs.isDir(curlbuild_h)) {
                debug.abort "What have you done? \"${curlbuild_h}\" is a folder..."
                return false;
            }

            // # cURL version.
            @CURL.CURL_VERSION = null;
            @CURL.CURL_VERSION_NUM = null;
            var curlver_h = File.readWhole(
                "${CURL_SOURCEDIR}/include/curl/curlver.h"
            );
            ;{
                var rt, matches = SLRE.match(
                    '#define LIBCURL_VERSION "(.*)"',
                    curlver_h
                );
                if(#matches > 0) {
                    @CURL.CURL_VERSION = matches[0];
                    detect.define("CURLVERSION", @CURL.CURL_VERSION);
                }
            }
            ;{
                var rt, matches = SLRE.match(
                    "#define LIBCURL_VERSION_NUM 0x([^\n]*)",
                    curlver_h
                );
                if(#matches > 0) {
                    @CURL.CURL_VERSION_NUM = matches[0];
                    detect.define("VERSIONNUM", @CURL.CURL_VERSION_NUM);
                }
            }

            // # Compiler
            detect.findCompiler("CC");

            // # Get canonical host...
            // Port: AC_CANONICAL_HOST ( cpu-maschine-OS )

            // # curl_off_t
            // QUOTE
            // Our curl_off_t internal and external configure settings
            // /QUOTE
            @CURL.CURL_CONFIGURE_CURL_OFF_T();

            // # AIX All-source
            // QUOTE
            // This defines _ALL_SOURCE for AIX
            // /QUOTE
            @CURL.CURL_CHECK_AIX_ALL_SOURCE();

            // QUOTE
            // Our configure and build reentrant settings
            // /QUOTE
            @CURL.CURL_CONFIGURE_THREAD_SAFE() || return false;
            @CURL.CURL_CONFIGURE_REENTRANT() || return false;

            // QUOTE: check for how to do large files
            autoconf.AC_SYS_LARGEFILE() || return false;

            // Normally, we'd encounter libtool specific calls here.
            // We skip them, end of story. :)
            // Thing is, it is mentioned that libcurl might need different flags,
            // depending on being build shared or not.
            // Look, IceTea sees this target as static - its marked "lib".
            // Here is where it gets interesting. If I was to define a shared library
            // target, I would have to undergo similar configuration. However,
            // instead I would simply use shared library flags.
            // So for now libcurl will build staticaly, and staticaly only,
            // under IceTea. When I implemented proper support for shlibs,
            // and found a smart way to maintain state between the two
            // so that I can mimimize re-run overhead, I will implement
            // support for a shared libcurl.

            // # Compiler checks
            @CURL.CURL_CHECK_COMPILER() || return false;
            @CURL.CURL_SET_COMPILER_BASIC_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_DEBUG_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_OPTIMIZE_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_WARNING_OPTS() || return false;

            // Skipping Intel UNIX C Check...

            @CURL.CURL_CHECK_COMPILER_HALT_ON_ERROR() || return false;
            @CURL.CURL_CHECK_COMPILER_ARRAY_SIZE_NEGATIVE() || return false;
            @CURL.CURL_CHECK_COMPILER_PROTOTYPE_MISMATCH() || return false;
            @CURL.CURL_CHECK_COMPILER_SYMBOL_HIDING() || return false;

            // Skipping Automake stuff

            @CURL.CURL_CHECK_CURLDEBUG() || return false;

            // And officially, the hard part IS. DONE.
            // According to cURL, we're now doing dependency checks and
            // other configuration. But the pardest part, which is
            // setting up the build environment, is obviously done.
            // ...
            // Phew. From hereon out, i might actually inline ports, instead
            // of attaching them to the CURL object.

            // Skipping Unittest configuration...
            // Skipping cross-compiling stuff...
            // Skipping IRIX checks...
            // Skipping AIX checks...

            detect.line "Checking for windows.h"
            if(detect.tryCompile([
                "#undef inline                                  ", // <- Huh?
                "#ifndef WIN32_LEAN_AND_MEAN                    ",
                "#define WIN32_LEAN_AND_MEAN                    ",
                "#endif                                         ",
                "#include <windows.h>                           ",
                "int main() {                                   ",
                "#if defined(__CYGWIN__) || defined(__CEGCC__)  ",
                "   HAVE_WINDOWS_H shall not be defined.        ",
                "#else                                          ",
                "   int dummy=2*WINVER;                         ",
                "#endif                                         ",
                "}                                              "
            ].join("\n"), "CC")) {
                // On Cygwin, we can't rely on windows.h
                @CURL.ac_cv_header_windows_h = true;
                detect.success "Found."
                detect.defineUnquoted("HAVE_WINDOWS_H", 1);
                detect.defineUnquoted("WIN32_LEAN_AND_MEAN");
            } else {
                @CURL.ac_cv_header_windows_h = false;
                detect.fail "No."
            }

            detect.line "Checking whether build target is a native Windows one";
            if(! @CURL.ac_cv_header_windows_h) {
                detect.fail "No."
            } else {
                if(detect.tryCompile([
                    "int main(int argc, char** argv) {                              ",
                    "#if defined(__MINGW32__) || defined(__MINGW32CE__) || \\       ",
                    "   (defined(_MSC_VER) && (defined(_WIN32) || defined(_WIN64))) ",
                    "   int dummy=1;                                                ",
                    "#else                                                          ",
                    "   Not a native Windows build target.                          ",
                    "#endif                                                         ",
                    "}                                                              "
                ].join("\n"), "CC")) {
                    @CURL.ac_cv_native_windows = true;
                    detect.success "Yes."
                } else {
                    @CURL.ac_cv_native_windows = false;
                    detect.fail "No."
                }
            }

            if(@CURL.ac_cv_native_windows) {
                // TBD:
                // CURL_CHECK_HEADER_WINSOCK
                // CURL_CHECK_HEADER_WINSOCK2
                // CURL_CHECK_HEADER_WS2TCPIP
                // CURL_CHECK_HEADER_WINLDAP
                // CURL_CHECK_HEADER_WINBER
            } else {
                // Mass-define all the false's
                for(var k,v in {
                    ac_cv_header_winsock_h:     false,
                    ac_cv_header_winsock2_h:    false,
                    ac_cv_header_ws2tcpip_h:    false,
                    ac_cv_header_winldap_h:     false,
                    ac_cv_header_winber_h:      false
                }) { @CURL[k] = v; }
            }

            // Skipping: CURL_CHECK_WIN32_LARGEFILE

            var support = function(name, cb, def) {
                def = def || true;
                detect.info "Checking whether to support ${name}"
                if(detect.enabled(name) && !detect.disabled(name)) {
                    detect.success "Yes."
                    return cb(true);
                } else if(!detect.enabled(name) && detect.disabled(name)) {
                    detect.fail "No."
                    return cb(true);
                } else {
                    return cb(def); // ALWAYS assume the positive default, if none given.
                }
            }
            support("http", {|bool|
                if(!bool) {
                    detect.warn "disable HTTP disables FTP over proxy and RTSP"
                    detect.define("CURL_DISABLE_HTTP", 1);
                    detect.define("CURL_DISABLE_RTSP", 1);
                }
            });
            support("ftp", {|b| !b && detect.define("CURL_DISABLE_FTP",1)});
            support("file", {|b| !b && detect.define("CURL_DISABLE_FILE", 1)});
            support("ldap", {|b| !b && detect.define("CURL_DISABLE_LDAP", 1)});
            support("ldaps", {|b|
                if(b == false) detect.define("CURL_DISABLE_LDAPS", 1);
                else if(b == true) {
                    if("CURL_DISABLE_LDAP" in detect.cache) {
                        detect.warn "LDAP needs to be enabled to support LDAPS"
                        detect.define("CURL_DISABLE_LDAPS", 1);
                    }
                } else {
                    if(!("CURL_DISABLE_LDAP" in detect.cache)) {
                        detect.fail "No."
                        detect.define("CURL_DISABLE_LDAPS", 1);
                    } else {
                        detect.success "Yes."
                        detect.define("HAVE_LDAP_SSL", 1);
                    }
                }
            }, "guess");
            support("rtsp", {|b|
                if(!b) detect.define("CURL_DISABLE_RTSP", 1);
                else if(b) {
                    if("CURL_DISABLE_HTTP" in detect.cache) {
                        detect.abort "HTTP support needs to be enabled in order to enable RTSP support!"
                        return false;
                    } else {
                        @CURL.curl_rtsp_msg = true;
                    }
                } else {
                    if("CURL_DISABLE_HTTP" in detect.cache) {
                        detect.fail "No."
                    } else {
                        detect.success "Yes."
                        @CURL.curl_rtsp_msg = true;
                    }
                }
                return true;
            }.bind(this)) || return false;
            support("proxy", {|b| !b && detect.define("CURL_DISABLE_PROXY", 1)});
            support("dict", {|b| !b && detect.define("CURL_DISABLE_DICT", 1)});
            support("telnet", {|b| !b && detect.define("CURL_DISABLE_TELNET", 1)});
            support("tftp", {|b| !b && detect.define("CURL_DISABLE_TFTP", 1)});
            support("pop3", {|b| !b && detect.define("CURL_DISABLE_POP3", 1)});
            support("imap", {|b| !b && detect.define("CURL_DISABLE_IMAP", 1)});
            support("smb", {|b| !b && detect.define("CURL_DISABLE_SMB", 1)});
            support("smtp", {|b| !b && detect.define("CURL_DISABLE_SMTP", 1)});
            support("gopher", {|b| !b && detect.define("CURL_DISABLE_GOPHER", 1)});

            // Skipping built-in manual...

            support("libcurl_option", function(that){
                if(!that) { // Then this.
                    detect.define("CURL_DISABLE_LIBCURL_OPTION", 1);
                    @CURL.curl_libcurl_msg = false;
                }
            }.bind(this));
            support("libgcc", {|b|
                if(b) {
                    if(detect.lib("gcc")) {
                        @settings.LINK.libraries[] = "gcc";
                        return true;
                    } else {
                        detect.abort "Can not link with libgcc!"
                        return false;
                    }
                }
            }.bind(this));

            // Port: CURL_CHECK_LIB_XNET
            detect.line "Checking if X/Open network library is required"
            @CURL.tst_lib_xnet_required = false;
            if(detect.tryCompile([
                "int main (void) {                                                      ",
                "#if defined(__hpux) && defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 600)",
                "  return 0;                                                            ",
                "#elif defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)               ",
                "  return 0;                                                            ",
                "#else                                                                  ",
                "  force compilation error                                              ",
                "#endif                                                                 ",
                "}                                                                      "
            ].join("\n"), "CC")) {
                detect.success "Yes."
                @CURL.tst_lib_xnet_required = true;
                @settings.LINK.libraries[] = "xnet";
            } else {
                detect.fail "No."
            }

            if(detect.func("gethostbyname")) {
                // By default, IceTea already macro's that one for us.
                // So, it's a noop now.
            } else {
                // Check if we have to use the nsl lib?
                if(detect.libfunc("nsl", "gethostbyname")) {
                    @settings.LINK.libraries[] = "nsl";
                }
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                if(detect.libfunc("socket", "gethostbyname")) {
                    @settings.LINK.libraries[] = "socket";
                } else if(detect.libfunc("watt", "gethostbyname")) {
                    @settings.LINK.libraries[] = "watt";
                    @settings.CC.includeDirs[] = "/dev/env/WATT_ROOT/inc";
                    @settings.LINK.libraryDirs[] = "/dev/env/WATT_ROOT/lib";
                } else {
                    // So, appearently there is one weird target that requires
                    // socket+nsl to let you use gethostbyname
                    // ... Damn.
                    detect.line "Checking for gethostbyname with both nsl and socket libs"
                    if(detect.tryCompile([
                        "int main(){        ",
                        "   gethostbyname();",
                        "   return 0;       ",
                        "}                  "
                    ].join("\n"), "CC", [
                        "-lnsl", "-lsocket"
                    ])) {
                        detect.success "Yes."
                        detect.define("HAVE_GETHOSTBYNAME", 1);
                        @settings.LINK.libraries += ["nsl", "socket"];
                    } else {
                        detect.fail "No."
                    }
                }
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                // For windows systems
                // Skipping windows-related checks...
                // Skipping Minix checks...
                // Skipping eCos checks...
                // Skipping Haiku OS checks...
                // Skipping BeOS checks...
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                detect.abort "couldn't find libraries for gethostbyname()"
                return false;
            }

            if(detect.func("strcasecmp")) {
                // noop
            } else if(detect.libfunc("resolve", "strcasecmp")) {
                @settings.LINK.libraries[] = "resolve";
            }

            // Port: CURL_CHECK_LIBS_CONNECT
            detect.line "Checking for connect in libraries"
            var tst_connect_need_LIBS = false;
            for(var n,flags in [
                [],         // None
                ["-lsocket"]// libsocket
            ]) {
                if(detect.tryCompile([
                    //@CURL.curl_includes_winsock2,
                    "#ifndef HAVE_WINDOWS_H             ",
                    "   int connect(int, void*, int);   ",
                    "#endif                             ",
                    "int main() {                       ",
                    "   if(0 != connect(0, 0, 0))       ",
                    "       return 1;                   ",
                    "}                                  "
                ].join("\n"), "CC", flags)) {
                    tst_connect_need_LIBS = flags;
                    break;
                }
            }
            if(tst_connect_need_LIBS != false) {
                for(var n,flag in tst_connect_need_LIBS) {
                    // Strip the "-l":
                    @settings.LINK.libraries[] = flag.sub(2);
                }
            } else {
                detect.fail "cannot find connect"
                detect.abort "cannot find connect function in libraries."
                return false;
            }

            @CURL.CURL_CHECK_LIBS_CLOCK_GETTIME_MONOTONIC();

            // Ok. So normally cURL would do some zlib testing now.
            // But I will first go and edit an API. Using IceTea,
            // we could also embed zlib. Sooo... instead, I'll also
            // test, if the target exists.
            var isWith,value = detect.isWith("zlib");
            var zFound = null;
            if(isWith) {
                @{ // Hack: Using a function, we can use return as a cheap short-circuit method!
                    if(value != "") {
                        if(wildcard.match("internal:*", value)) {
                            // Requested a reachable zlib through IceTea...
                            var tName = value.split(":")[1];
                            detect.line "Checking for IceTea-reachable zlib: ${tName}"
                            if(IceTea.hasTarget(tName)) {
                                detect.success "Found"
                                @needs[] = tName;
                                return;
                            } else {
                                detect.fail "Not found. Continuing search."
                            }
                        }
                        // Back up the current settings...
                        // We create a new array to hold the backup,
                        // since the + operator modifies the this of the array.
                        detect.line "Searching for libz includes in: ${value}"
                        var includeDir = pfs.join(value, "include");
                        if(!pfs.isDir(includeDir)) {
                            detect.fail "Not found."
                        } else {
                            detect.success "Found: ${includeDir}"
                            detect.line "Searching for libz libraries in: ${value}\n"
                            for(var n,dirname in ["lib", "lib32", "lib64"]) {
                                var libPath = pfs.join(value, dirname);
                                if(pfs.isDir(libPath)) {
                                    var list = pfs.glob(libPath, "libz.*");
                                    if(#list) {
                                        // Even on windows, it has the "lib" prefix.
                                        // Therefore, we can cheat, and just omit the extension
                                        // instead.
                                        for(var n,libfile in list) {
                                            if(detect.libfunc(libfile, "inflateEnd")) {
                                                @settings.LINK.libraries[] = libfile;
                                                @settings.native.includeDirs[] = includeDir;
                                                print detect.out;
                                                detect.success "Found: ${libfile}"
                                                return;
                                            }
                                        }
                                    } else continue;
                                } else continue;
                            }
                        }
                    } else {
                        // Search the usual way.
                        if(detect.header("c", "zlib.h") && detect.libfunc("z", "inflateEnd")) {
                            // Well, since IceTea defines stuff already,
                            // and since only both can pass, it's pretty straight forward.
                            // We do: nothing.
                            @curl_zlib_msg = "enabled"
                            return;
                        }
                    }
                };
            }

            @CURL.LBERLIBNAME = cli.value("--with-curl-lber-lib");
            @CURL.LDAPLIBNAME = false;
            detect.line "Testing LADP usability via: ${@CURL.LDAPLIBNAME}\n"
            if(detect.isWith("curl-lber-lib")) {
                if(!("CURL_DISABLE_LDAP" in detect.cache)) {
                    // FIXME: detect.hasDefine(macro) - would help a lot o.o;
                    // TBD:
                    // @CURL.CURL_CHECK_HEADER_LBER();
                    // @CURL.CURL_CHECK_HEADER_LDAP();
                    // @CURL.CURL_CHECK_HEADER_LDAPSSL();
                    // @CURL.CURL_CHECK_HEADER_LDAP_SSL();
                    if(@CURL.LDAPLIBNAME == false) {
                        if(@CURL.ac_cv_native_windows) {
                            print detect.out;
                            detect.success "Using Win32 LDAP stuff"
                            // Native windows, there actually is a set library.
                            @settings.LINK.libraries[] = "wldap32";
                            @CURL.LDAPLIBNAME = "wldap32";
                            @CURL.LBERLIBNAME = false;
                        }
                    }
                    if(@CURL.LDAPLIBNAME != false) {
                        // I need a better "is not empty" check. But I'm lazy o.o
                        if(! detect.libfunc(@CURL.LDAPLIBNAME, "ldap_init")) {
                            print detect.out;
                            detect.fail "\"${@CURL.LDAPLIBNAME}\" is not an LDAP library: LDAP disabled"
                            detect.define("CURL_DISABLE_LDAP", 1);
                            detect.define("CURL_DISABLE_LDAPS", 1);
                        }
                    } else {
                        // Do an actual search instead of relying on the user.
                        // TBD:
                        // @CURL.CURL_CHECK_LIBS_LDAP();
                        if(! @CURL.curl_cv_ldap_LIBS) {
                            print detect.out;
                            detect.fail "Cannot find libraries for LDAP support: LDAP disabled"
                            detect.define("CURL_DISABLE_LDAP", 1);
                            detect.define("CURL_DISABLE_LDAPS", 1);
                        }
                    }
                }
            }
            if(@CURL.LBERLIBNAME != false && @CURL.LBERLIBNAME != "") {
                // Normally we'd see if it reads "no".
                // But since cli.value() returns an empty string otherwise,
                // we can't really do that.
                if(detect.libfunc(@CURL.LBERLIBNAME, "ber_free")) {
                    print detect.out;
                    detect.fail "${@CURL.LBERLIBNAME} is not an LBER library: LDAP disabled"
                    detect.define("CURL_DISABLE_LDAP", 1);
                    detect.define("CURL_DISABLE_LDAPS", 1);
                }
            }
            if(!("CURL_DISABLE_LDAP" in detect.cache)) {
                // Shouldn't I be using some sort of library here?
                // It isn't clear, if the library (inside the AC context)
                // is added to LDFLAGS by now?
                detect.func("ldap_url_parse");
                detect.func("ldap_init_fd");

                if(@CURL.LDAPLIBNAME == "wldap32") {
                    @CURL.curl_ldap_msg = "enabled (wldap32)"
                    detect.define("USE_WIN32_LDAP", 1);
                } else {
                    @CURL.curl_ldap_msg = "enabled (OpenLDAP)";
                    detect.define("USE_OPENLDAP", 1);
                }
            }

            if(!("CURL_DISABLE_LDAPS" in detect.cache)) {
                @CURL.curl_ldaps_msg = "enabled";
            }

            // # ipv6
            // Finally away from this LDAP stuff. Although there are TBDs...
            // so I have to return to it later. *gulp*.
            detect.line "Checking whether to enable IPv6";
            if(detect.enabled("curl-ipv6") && !detect.disabled("curl-ipv6")) {
                detect.success "Yes."
                @CURL.ipv6 = true;
            } else {
                detect.fail "No."
                @CURL.ipv6 = false;
            }
            if(@CURL.ipv6) {
                detect.line "Is AF_INET6 available?"
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "/* is AF_INET6 available? */   ",
                    "#include <sys/types.h>         ",
                    "#ifdef HAVE_WINSOCK2_H         ",
                    "#include <winsock2.h>          ",
                    "#else                          ",
                    "#include <sys/socket.h>        ",
                    "#endif                         ",
                    "#include <stdlib.h> /*exit()*/ ",
                    "int main() {                   ",
                    "if (socket(                    ",
                    "       AF_INET6,               ",
                    "       SOCK_STREAM,            ",
                    "       0                       ",
                    ") < 0) exit(1);                ",
                    "else exit(0);                  ",
                    "}                              "
                ].join("\n"), "CC")) {
                    detect.success "Yes";
                    // Definitively keep ipv6 on!
                    @CURL.ipv6 = true;
                } else {
                    detect.fail "No"
                    @CURL.ipv6 = false;
                }
            }
            if(@CURL.ipv6) {
                @CURL.curl_ipv6_msg = "enabled";
            } else {
                @CURL.curl_ipv6_msg = "disabled";
            }
            if(@CURL.ipv6) {
                detect.line "Checking if struct sockaddr_in6 has sin6_scope_id member"
                if(detect.tryCompile([
                    "#include <sys/types.h> ",
                    "#ifdef HAVE_WINSOCK2_H ",
                    "#include <winsock2.h>  ",
                    "#include <ws2tcpip.h>  ",
                    "#else                  ",
                    "#include <netinet/in.h>",
                    "#endif                 ",
                    "int main() {           ",
                    " struct sockaddr_in6 s;",
                    " s.sin6_scope_id = 0;  ",
                    "}                      "
                ].join("\n"), "CC")) {
                    detect.success "Yes."
                    @CURL.have_sin6_scope_id = true;
                    detect.define("HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID", 1);
                } else {
                    detect.fail "No."
                }
            }

            detect.line "Checking if argv can be written to"
            var built, spawned, exitCode = detect.tryCompile([
                "int main(int argc, char ** argv) { ",
                "    argv[0][0] = ' ';              ",
                "    return (argv[0][0] == ' ')?0:1;",
                "}                                  "
            ].join("\n"), "CC");
            if(built && spawned) {
                if(exitCode == 0) {
                    detect.success "Yes"
                    @CURL.curl_cv_writable_argv = true;
                    detect.define("HAVE_WRITABLE_ARGV", 1);
                } else if(exitCode == 1) {
                    detect.success "No"
                    @CURL.curl_cv_writable_argv = false;
                }
            } else {
                detect.warn "the previous check could not be made default was used"
            }

            // # GSS-API
            // TODO: Implementing all the checks neccessary for this to work.
            // Workaround: GSS-API is disabled by default, for now.
            //@CURL.CURL_CONFIGURE_GSSAPI();

            // # SSL
            // Here we will check all the things SSL!
            @CURL.SSL_CONFIGURED = false;

            // ## Windows SSL
            detect.line "Checking whether to enable Windows native SSL/TLS (Windows native builds only)"
            if(detect.isWith("curl-winssl") && !@CURL.SSL_CONFIGURED) {
                if(@CURL.ac_cv_native_windows) {
                    detect.success "Yes.";
                    @CURL.SSL_CONFIGURED = true;
                    detect.define("USE_SCHANNEL", 1);
                    @CURL.curl_ssl_msg = "enabled (Windows-native)";
                    detect.define("USE_WINDOWS_SSPI", 1);
                    @CURL.curl_sspi_msg = "enabled";
                } else {
                    detect.fail "No."
                }
            } else detect.status "Skip."

            // ## Darwin SSL aka. OS X native SSL
            detect.line "Checking whether to enable iOS/Mac OS X native SSL/TLS"
            if(detect.isWith("curl-darwinssl") && !@CURL.SSL_CONFIGURED) {
                if(pfs.isDir("/System/Library/Frameworks/Security.framework")) {
                    detect.success "Yes"
                    @CURL.SSL_CONFIGURED = true;
                    detect.define("USE_DARWINSSL", 1);
                    @CURL.curl_ssl_msg = "enabled (iOS/Mac OS X-native)";
                    // FIXME: -framework support
                    @settings.LINK.flags += [
                        "-framework CoreFoundation",
                        "-framework Security"
                    ];
                } else {
                    detect.fail "No"
                }
            } else detect.status "Skip"

            // ## Non-native libraries (PolarSSL, mbedTLS, ...)
            @CURL.ca = false;
            var withSsl, sslPath = detect.isWith("curl-ssl");
            detect.line "cURL with SSL: OpenSSL\n"
            if(withSsl && !@CURL.SSL_CONFIGURED) {
                // Skip MinGW / MSYS check...
                if(sslPath == "") {
                    // No path given.
                    // Skip cross-compile check...
                    @CURL.PKGTEST = true;
                    @CURL.PREFIX_OPENSSL = "/usr/local/ssl";
                    @curl.LIB_OPENSSL="${@CURL.PREFIX_OPENSSL}/lib";
                } else {
                    @CURL.PKGTEST = false;
                    @CURL.PREFIX_OPENSSL = sslPath;
                    // Do a pkg-config test.
                    @CURL.OPENSSL_PCDIR = "${sslPath}/lib/pkgconfig";
                    detect.notice "PKG_CONFIG_LIBDIR will be set to \"${@CURL.OPENSSL_PCDIR}\""
                    if(pfs.isDir("${@CURL.OPENSSL_PCDIR}/openssl.pc")) {
                        @CURL.PKGTEST = true;
                    }
                    @CURL.LIB_OPENSSL = "${@CURL.PREFIX_OPENSSL}/lib";
                    if(@CURL.PREFIX_OPENSSL != "/usr") {
                        @CURL.SSL_LDFLAGS="-L${@CURL.LIB_OPENSSL}"
                        @CURL.SSL_CPPFLAGS="-I${@CURL.PREFIX_OPENSSL}/include"
                    }
                    @CURL.SSL_CPPFLAGS = "${@CURL.SSL_CPPFLAGS} -I${@CURL.PREFIX_OPENSSL}/include/openssl";

                    if(@CURL.PKGTEST) {
                        if(detect.tool("pkg-config")) {
                            for(var localName,args in {
                                "SSL_LIBS":     "--libs-only-l",
                                "SSL_LDFLAGS":  "--libs-only-L",
                                "SSL_CPPFLAGS": "--cflags-only-I"
                            }) {
                                var proc = SubProcess({async: false});
                                proc.set_env("PKG_CONFIG_LIBDIR", @CURL.OPENSSL_PCDIR);
                                print "- pkg-config: ENV[PKG_CONFIG_LIBDIR] = ${@CURL.OPENSSL_PCDIR}";
                                var cmd = "pkg-config ${args} openssl";
                                print "- pkg-config: $ ${cmd}";
                                var spawned = proc.execute(cmd);
                                if(spawned) {
                                    var ec = proc.exit_code();
                                    if(ec == 0) {
                                        var stdout = proc.stdout().trim();
                                        print "- pkg-config: ${localName} = ${stdout}"
                                        @CURL[localName] = stdout;
                                    } else {
                                        print "- pkg-config: Failed. (Status: ${ec})"
                                    }
                                } else {
                                    print "- pkg-config: Process not spawned"
                                }
                            }
                            @CURL.LIB_OPENSSL = @CURL.SSL_LDFLAGS.replace("-L", "");

                            // Save the results.
                            @settings.LINK.libraries
                                += @CURL.SSL_LIBS.replace("-l","").split(" ");
                            @settings.LINK.libraryDirs
                                += @CURL.SSL_LDFLAGS.replace("-L","").split(" ");
                            @settings.native.includeDirs
                                += @CURL.SSL_CPPFLAGS.replace("-I", "").split(" ");
                        } else {
                            detect.status "No pkg-config found. Skipping."
                        }
                    }
                }

                // Now, look for crypto stuff.
                if(detect.libfunc("crypto", "HMAC_Update")) {
                    @settings.LINK.libraries[] = "crypto";
                    detect.define("HAVECRYPTO", 1);
                } else if(detect.libfunc(
                    "crypto", "HMAC_Init_ex",
                    "c", [] + @CURL.SSL_CPPFLAGS
                            + @CURL.SSL_LDFLAGS
                            + @CURL.SSL_LIBS
                )) {
                    // ACTUALLY I doubt that this will work.
                    // My test for a function in a library goes through dlopen()...
                    // That means, that I am pretty guaranteed to have THIS check fail.
                    // I'd need to find the actual library FIRST, and give the
                    // full path.
                    // FIXME: Better libfunc().

                }

                if("HAVECRYPTO" in detect.cache) {
                    detect.line "Checking OpenSSL linking without -ldl"
                    var tst_src = [
                        "#include <openssl/evp.h>       ",
                        "int main() {                   ",
                        "   SSLeay_add_all_algorithms();",
                        "}                              "
                    ].join("\n");
                    if(detect.tryCompile(tst_src, "CC")) {
                        detect.success "Works"
                    } else {
                        detect.fail "No"
                        detect.line "Retry WITH -dl"
                        if(detect.tryCompile(tst_src, "CC", "-ldl")) {
                            detect.success "This works."
                            @settings.LINK.libraries[] = "dl";
                        } else {
                            detect.fail "Nope."
                        }
                    }

                    // Crypto checks
                    var has = detect.libfunc("ssl", "SSL_connect");
                    if(!has) {
                        detect.line "Checking for ssl with RSAglue/rsaref libs in use"
                        // Now I wish I could just pass the target's Settings object...
                        // I need a way to do that. It would save tons of time.
                        if(detect.libfunc(
                            "ssl","SSL_connect",
                            "c", "-lRSAglue -lrsaref -lssl"
                        )) {
                            detect.success "Yes"
                            @settings.LINK.libraries += ["RSAglue","rsaref"];
                        } else {
                            detect.fail "No"
                        }
                    } else {
                        for(var n,hdr in [
                            "openssl/x509.h",
                            "openssl/rsa.h",
                            "openssl/crypto.h",
                            "openssl/pem.h",
                            "openssl/ssl.h",
                            "openssl/err.h"
                        ]) detect.header("c", hdr);

                        @CURL.curl_ssl_msg = "enabled (OpenSSL)";
                        detect.define("USE_OPENSSL", 1);
                        @CURL.OPENSSL_ENABLED = true;

                        if(!detect.header("openssl/x509.h")) {
                            var matches = 0;
                            for(var n,hdr in [
                                "x509.h",
                                "rsa.h",
                                "crypto.h",
                                "pem.h",
                                "ssl.h",
                                "err.h"
                            ]) {
                                detect.header("c", hdr) && @{ matches++; };
                            }
                            if(matches >= 3) {
                                @CURL.curl_ssl_msg = "enabled (OpenSSL)";
                                @CURL.OPENSSL_ENABLED = true;

                            }
                        }
                    }
                    if(@CURL.OPENSSL_ENABLED) {
                        detect.header("c", "openssl/pkcs12.h");
                    }
                    // fixme: proper "OpenSSL libs and/or directories were not found where specified!" check.
                    if(@CURL.OPENSSL_ENABLED) {
                        // Skipping ENGINE checks...
                        // Reason: I'll have to attach _ALL_ the LDFLAGS/CPPFLAGS/... which were
                        // gathered. That means I actually would need to carry a whole
                        // kind of settings object. Which I currently don't.
                        // When I revisit this, this should be topmost prio,
                        // because cURL depends on some of these information.
                        // I can get away with the fact that i'll actually skip
                        // OpenSSL and just _enforce_ mbedTLS instead... but, yeah,
                        // thats still cheating.

                        // Also skipping these checks:
                        // - BoringSSL
                        // - libressl
                        // - LD_LIBRARY_PATH
                    }
                }
            }

            // ## Random seed
            // Skip: egd-socket
            // Skip: /dev/urandom (Because the default is enough here).
            detect.defineQuoted("RANDOM_FILE", "/dev/urandom");
            // Skip: OpenSSL with SRP
            // Skip: GnuTLS
            // Skip: GnuTLS crypto backend
            // Skip: GnuTLS with SRP
            // Skip: PolarSSL (Besides, it's deprecated!)

            // ## mbedTLS
            if(
                (IceTea.hasTarget("mbedtls") || detect.isWith("curl-mbedtls"))
                && !@CURL.SSL_CONFIGURED
            ) {
                if(IceTea.hasTarget("mbedtls")) {
                    @needs[] = "mbedtls";
                    detect.define("USE_MBEDTLS", 1);
                    @CURL.curl_ssl_msg = "enabled (mbedTLS (IceTea target))";
                    @CURL.SSL_CONFIGURED = true;
                    // I wish this was always that easy. o.o...
                } else {
                    if(detect.libfunc("mbedtls", "mbedtls_havege_init")) {
                        detect.define("USE_MBEDTLS", 1);
                        @CURL.curl_ssl_msg = "enabled (mbedTLS)";
                        @settings.LINK.libraries += ["mbedx509","mbedcrypto"];
                        @CURL.USE_MBEDTLS = true;
                    } else {
                        @CURL.USE_MBEDTLS = false;
                    }

                    if(!@CURL.USE_MBEDTLS) {
                        // And once again: I can't test library paths with libfunc...
                        // Therefore, I'll just skip this part.
                        // I really need to sit down on this issue. Did you count how
                        // many times in a single source file I have complained about
                        // a single API; and the worst part; it's one I wrote myself?!
                        // I am a -horrible- person 0.0
                    }
                }
            }

            // Skip: CyaSSL
            // Skip: NSS
            if(!@CURL.SSL_CONFIGURED) {
                detect.warn "SSL disabled, you will not be able to use HTTPS, FTPS, NTLM and more."
                detect.warn "Use --help to see the available SSL options (they're vast! (but not all configurable...))"
            }

            @CURL.CURL_CHECK_CA_BUNDLE();

            // Skip: libpsl
            // Skip: libmetalink
            // Skip: libssh2
            // Skip: librtmp
            // Skip: Versioned Symbols linker switch

            // # IDN
            // Skip: winidn
            // Skip: libidn

            // Skip: nghttp2 (Although that'd be interesting to have...)
            // Skip: zsh completions

            // Now they promised me: Back to normal configure.
            // After LDAP, OpenSSL and others, I really hope you're serious! =)
            autoconf.AC_HEADER_STDC();
            @CURL.CURL_CHECK_HEADER_MALLOC();
            @CURL.CURL_CHECK_HEADER_MEMORY();

            // TIME FOR A HEADER BOMB!
            // I'm listening to dubstep right now. Am I allowed to say: "Drop the header!"?
            for(var n,hdr in [
                "sys/types.h",  "sys/time.h",   "sys/select.h", "sys/socket.h",
                "sys/ioctl.h",  "sys/uio.h",    "assert.h",     "unistd.h",
                "stdlib.h",     "limits.h",     "arpa/inet.h",  "net/if.h",
                "netinet/in.h", "sys/un.h",     "netinet/tcp.h","netdb.h",
                "sys/sockio.h", "sys/stat.h",   "sys/param.h",  "termios.h",
                "termio.h",     "sgtty.h",      "fcntl.h",      "alloca.h",
                "time.h",       "io.h",         "pwd.h",        "utime.h",
                "sys/utime.h",  "sys/poll.h",   "poll.h",       "socket.h",
                "sys/resource.h",               "libgen.h",     "locale.h",
                "errno.h",      "stdbool.h",    "arpa/tftp.h",  "sys/filio.h",
                "sys/wait.h",   "setjmp.h"
            ]) detect.header("c",hdr);

            detect.settings.preSource += [
                "#ifdef HAVE_SYS_TYPES_H    ",
                "#include <sys/types.h>     ",
                "#endif                     ",
                "#ifdef HAVE_SYS_TIME_H     ",
                "#include <sys/time.h>      ",
                "#endif                     ",
                "#ifdef HAVE_SYS_SELECT_H   ",
                "#include <sys/select.h>    ",
                "#endif                     ",
                "#ifdef HAVE_SYS_SOCKET_H   ",
                "#include <sys/socket.h>    ",
                "#endif                     ",
                "#ifdef HAVE_NETINET_IN_H   ",
                "#include <netinet/in.h>    ",
                "#endif                     ",
                "#ifdef HAVE_SYS_UN_H       ",
                "#include <sys/un.h>        ",
                "#endif                     ",
                "" // Additional newline
            ].join("\n");

            autoconf.AC_C_CONST();
            @CURL.CURL_CHECK_VARIADIC_MACROS();
            detect.sizeof("size_t");
            autoconf.AC_HEADER_TIME();
            @CURL.CURL_CHECK_STRUCT_TIMEVAL();
            @CURL.CURL_VERIFY_RUNTIMELIBS();

            for(var n,type in [
                "long", "int", "short",
                "time_t", "off_t"
            ]) detect.sizeof(type);

            @CURL.CURL_CONFIGURE_LONG();

            // Skip: soname

            if(detect.type("long long")) {
                detect.define("HAVE_LONGLONG", 1);

                detect.line "Checking if numberLL works";
                if(detect.tryCompile([
                    "int main(){                ",
                    "   long long val = 1000LL; ",
                    "}                          "
                ].join("\n"), "CC")) {
                    detect.succes "Yes"
                    detect.define("HAVE_LL", 1);
                } else {
                    detect.fail "No"
                }
            }

            if(!detect.type("ssize_t")) {
                detect.define("ssize_t", "int");
            }

            if(detect.type("bool")) {
                detect.define("HAVE_BOOL_T", 1);
            }

            // When doing AC_CHECK_TYPE, is the third argument like a finally{} block,
            // and always executed? o.o I only guess so, that's why I am
            // actually appending to preSource.
            detect.settings.preSource += [
                "#ifdef HAVE_SYS_TYPES_H    ",
                "#include <sys/types.h>     ",
                "#endif                     ",
                "#ifdef HAVE_STDBOOL_H      ",
                "#include <stdbool.h>       ",
                "#endif                     ",
                "" // Cause additional newline.
            ].join("\n");

            @CURL.CURL_CONFIGURE_CURL_SOCKLEN_T();

            @CURL.CURL_CONFIGURE_PULL_SYS_POLL();

            @CURL.TYPE_IN_ADDR_T();
            @CURL.TYPE_SOCKADDR_STORAGE();
            @CURL.TYPE_SIG_ATOMIC_T();

            autoconf.AC_TYPE_SIGNAL();

            @CURL.CURL_CHECK_FUNC_SELECT();
            @CURL.CURL_CHECK_FUNC_RECV();
            @CURL.CURL_CHECK_FUNC_SEND();
            @CURL.CURL_CHECK_MSG_NOSIGNAL();
            @CURL.CURL_CHECK_FUNC_ALARM();
            @CURL.CURL_CHECK_FUNC_BASENAME();
            @CURL.CURL_CHECK_FUNC_CLOSESOCKET();
            @CURL.CURL_CHECK_FUNC_CLOSESOCKET_CAMEL();
            @CURL.CURL_CHECK_FUNC_CONNECT();
            @CURL.CURL_CHECK_FUNC_FCNTL();
            @CURL.CURL_CHECK_FUNC_FDOPEN();
            @CURL.CURL_CHECK_FUNC_FREEADDRINFO();
            @CURL.CURL_CHECK_FUNC_FREEIFADDRS();
            @CURL.CURL_CHECK_FUNC_FSETXATTR();
            @CURL.CURL_CHECK_FUNC_FTRUNCATE();
            @CURL.CURL_CHECK_FUNC_GETADDRINFO();
            @CURL.CURL_CHECK_FUNC_GAI_STRERROR();
            @CURL.CURL_CHECK_FUNC_GETHOSTBYADDR();
            @CURL.CURL_CHECK_FUNC_GETHOSTBYADDR_R();
            @CURL.CURL_CHECK_FUNC_GETHOSTBYNAME();
            @CURL.CURL_CHECK_FUNC_GETHOSTBYNAME_R();
            @CURL.CURL_CHECK_FUNC_GETHOSTNAME();
            @CURL.CURL_CHECK_FUNC_GETIFADDRS();
            @CURL.CURL_CHECK_FUNC_GETSERVBYPORT_R();
            @CURL.CURL_CHECK_FUNC_GMTIME_R();
            @CURL.CURL_CHECK_FUNC_INET_NTOA_R();
            @CURL.CURL_CHECK_FUNC_INET_NTOP();
            @CURL.CURL_CHECK_FUNC_INET_PTON();
            @CURL.CURL_CHECK_FUNC_IOCTL();
            @CURL.CURL_CHECK_FUNC_IOCTLSOCKET();
            @CURL.CURL_CHECK_FUNC_IOCTLSOCKET_CAMEL();
            @CURL.CURL_CHECK_FUNC_LOCALTIME_R();
            @CURL.CURL_CHECK_FUNC_MEMRCHR();
            @CURL.CURL_CHECK_FUNC_POLL();
            @CURL.CURL_CHECK_FUNC_SETSOCKOPT();
            @CURL.CURL_CHECK_FUNC_SIGACTION();
            @CURL.CURL_CHECK_FUNC_SIGINTERRUPT();
            @CURL.CURL_CHECK_FUNC_SIGNAL();
            @CURL.CURL_CHECK_FUNC_SIGSETJMP();
            @CURL.CURL_CHECK_FUNC_SOCKET();
            @CURL.CURL_CHECK_FUNC_SOCKETPAIR();
            @CURL.CURL_CHECK_FUNC_STRCASECMP();
            @CURL.CURL_CHECK_FUNC_STRCMPI();
            @CURL.CURL_CHECK_FUNC_STRDUP();
            @CURL.CURL_CHECK_FUNC_STRERROR_R();
            @CURL.CURL_CHECK_FUNC_STRICMP();
            @CURL.CURL_CHECK_FUNC_STRNCASECMP();
            @CURL.CURL_CHECK_FUNC_STRNCMPI();
            @CURL.CURL_CHECK_FUNC_STRNICMP();
            @CURL.CURL_CHECK_FUNC_STRSTR();
            @CURL.CURL_CHECK_FUNC_STRTOK_R();
            @CURL.CURL_CHECK_FUNC_STRTOLL();
            @CURL.CURL_CHECK_FUNC_WRITEV();

            // SKIP: djgpp check

            for(var n,func in [
                "fork",             "geteuid",
                "getpass_r",        "getppid",
                "getprotobyname",   "getpwuid",
                "getpwuid_r",       "getrlimit",
                "gettimeofday",     "if_nametoindex",
                "inet_addr",        "perror",
                "pipe",             "setlocale",
                "setmode",          "setrlimit",
                "uname",            "utime"
            ]) detect.func(func);

            @CURL.CURL_CHECK_FUNC_GETNAMEINFO();

            if(@CURL.ipv6) {
                if(detect.func("getaddrinfo")) {
                    detect.define("ENABLE_IPV6", 1);
                }
                @CURL.CURL_CHECK_NI_WITHSCOPEID();
            }

            @CURL.CURL_CHECK_NONBLOCKING_SOCKET();

            // Skip: nroff/groff
            // Skip: built-in manual

            @CURL.CURL_CHECK_LIB_ARES();

            // Skip: Native Windows: libhostname build

            @CURL.CURL_CHECK_OPTION_THREADED_RESOLVER();

            // Skip: --enable-threaded-resolver & --enable-ares
            // I don't actually understand the error message, that's why I'm skipping this.

            if(
                detect.enabled("curl-threaded-resolver")
                && detect.header("c","pthread.h")
            ) {
                // Here's it again, libfunc!
                // Thing is, libfunc uses dlopen.
                // dlopen uses the linker's search path.
                // So even if I test for pthread_create(), it IS going to match,
                // since libpthread is likely in the linker's search path.
                // So, I can't do a reliable check on that, yet...

                if(detect.func("pthread_create")) {
                    detect.define("USE_THREADS_POSIX",1);
                    @CURL.curl_res_msg = "POSIX threaded"
                }
            }

            if(! detect.enabled("curl-verbose-strings")) {
                detect.define("CURL_DISABLE_VERBOSE_STRINGS", 1);
            }

            detect.line "whether to enable SSPI support (Windows native builds only)"
            if(detect.enabled("curl-sspi")) {
                if(@CURL.ac_cv_native_windows) {
                    detect.success "Yes"
                    detect.define("USE_WINDOWS_SSPI", 1);
                    @CURL.curl_sspi_msg = "enabled"
                } else {
                    detect.fail "No. --enable-curl-sspi Ignored. Only supported on native Windows builds."
                }
            } else if("WINSSL_ENABLED" in detect.cache) {
                detect.success "Yes"
            } else {
                detect.fail "No"
            }

            detect.line "Checking whether to enable cryptographic authentication methods"
            if(!detect.enabled("curl-crypto-auth")) {
                detect.define("CURL_DISABLE_CRYPTO_AUTH", 1);
                detect.fail "No"
            } else {
                detect.success "Yes"
            }

            @CURL.CURL_CHECK_OPTION_NTLM_WB();
            @CURL.CURL_CHECK_NTLM_WB();

            // Skip: TLS-SRP authentication
            // Skip: Unix domain sockets. Reason: Implement autoconf.AC_CHECK_MEMBER

            if(detect.disabled("curl-cookies")) {
                detect.define("CURL_DISABLE_COOKIES", 1);
            }

            @CURL.CURL_CONFIGURE_SYMBOL_HIDING();

            // Skip: SONAME version bump
            // Reason: I only really know how to do that on OS X. Besides,
            // the default build is staticaly anyway... so, there is no SONAME.

            // Major skip:
            // - pkg-config
            // - curl-config script variables
            // - Makefile substitutes
            // - Makefile generation
            // - Protocol summary (SUPPORT_PROTOCOLS). I NEED to do it though.

            print [
                "",
                "Configured to build curl/libcurl:",
                "",
                "  curl version:     ${CURLVERSION}",
                "  Host setup:       ${detect.host()}",
                "  Install prefix:   ${detect.prefix()}",
                "  Compiler:         ${detect.toolCache.CC}",
                "  SSL support:      ${@CURL.curl_ssl_msg}",
                "  SSH support:      ${@CURL.curl_ssh_msg}",
                "  zlib support:     ${@CURL.curl_zlib_msg}",
                "  GSS-API support:  ${@CURL.curl_gss_msg}",
                "  TLS-SRP support:  ${@CURL.curl_tls_srp_msg}",
                "  resolver:         ${@CURL.curl_res_msg}",
                "  IPv6 support:     ${@CURL.curl_ipv6_msg}",
                "  Unix sockets support: ${@CURL.curl_unix_sockets_msg}",
                "  IDN support:      ${@CURL.curl_idn_msg}",
                "  Build libcurl:    Static by default via IceTea",
                "  Built-in manual:  ${@CURL.curl_manual_msg}",
                "  --libcurl option: ${@CURL.curl_libcurl_msg}",
                "  Verbose errors:   ${@CURL.curl_verbose_msg}",
                "  SSPI support:     ${@CURL.curl_sspi_msg}",
                "  ca cert bundle:   ${@CURL.ca}${@CURL.ca_warning}",
                "  ca cert path:     ${@CURL.capath}${@CURL.capath_warning}",
                "  ca fallback:      ${@CURL.with_ca_fallback}",
                "  LDAP support:     ${@CURL.curl_ldap_msg}",
                "  LDAPS support:    ${@CURL.curl_ldaps_msg}",
                "  RTSP support:     ${@CURL.curl_rtsp_msg}",
                "  RTMP support:     ${@CURL.curl_rtmp_msg}",
                "  metalink support: ${@CURL.curl_mtlnk_msg}",
                "  PSL support:      ${@CURL.curl_psl_msg}",
                "  HTTP2 support:    ${@CURL.curl_h2_msg}",
                "  Protocols:        ${@CURL.SUPPORT_PROTOCOLS}",
                ""
            ].join("\n");
        };

        // Done.
        detect.settings = __DCT_SETTINGS;

        return ConfigureReturn;
    },
    settings: {
        native: {
            includeDirs: [pfs.join(
                dep.get("curl"),
                "include"
            )]
        },
        CC: {
            flags: [],
            includeDirs: [],
            defines: []
        },
        LINK: {
            libraries: [],
            libraryDirs: []
        }
    },
    exports: {
        native: {
            includeDirs: [pfs.join(
                dep.get("curl"),
                "include"
            )]
        }
    }
}
