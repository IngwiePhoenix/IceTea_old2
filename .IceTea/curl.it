/**
 * @file: cURL itnerface for IceTea.
 *
 * I used the configure files as reference for building this file.
 * Some of the more interesting comments are copied unedited (except syntactialy)
 * so that the meaning of some of the things that are done here are preserved.
 *
 * They will be framed by a leading and ending QUOTE or /QUOTE keyword.
 *
 * The main operations are done on the target's CURL object.
 * In it, you will find ports of several functions defined in the .m4 files.
 */

var dep = require("deps");
var CURL_SOURCEDIR = dep.get("curl");
target("curl", "lib") {
    title: "cURL",
    input: [],
    needs: ["mbedtls"],
    // Private variables, used across.
    CURL: {
        // Properties
        sslLibs: [
            "ssl",
            "gnutls",
            "nss",
            "polarssl",
            "mbedtls",
            "cyassl",
            "axtls",
            "winssl",
            "darwinssl"
        ],
        otherLibs: [
            "libssh2",
            "zlib",
            "gssapi",
            "librtmp",
            "libmetalink",
            "libpsl"
        ],
        windowsLibs: [
            "libidn",
            "winidn"
        ],
        genericEnables: [ // Add name defs
            "ipv6",
            "unix-sockets",
            "sspi",
            "rtsp"
        ],

        CURL_INCLUDES_INTTYPES: function() {
            if("_curl_includes_inttypes" in this) return;
            else @_curl_includes_inttypes = true;
            @curl_includes_inttypes_src = [
                "/* includes start */   ",
                "#ifdef HAVE_SYS_TYPES_H",
                "# include <sys/types.h>",
                "#endif                 ",
                "#ifdef HAVE_STDINT_H   ",
                "# include <stdint.h>   ",
                "#endif                 ",
                "#ifdef HAVE_INTTYPES_H ",
                "# include <inttypes.h> ",
                "#endif                 ",
                "/* includes end */     "
            ].join("\n");
            for(var n,hdr in [
                "sys/types.h",
                "stdint.h",
                "inttypes.h"
            ]) detect.header(hdr);
        },

        // Methods
        CURL_CONFIGURE_CURL_OFF_T: function() {
            // Deps
            @CURL_INCLUDES_INTTYPES();
            autoconf.AC_SYS_LARGEFILE();
            @CURL_CONFIGURE_REENTRANT();
            @CURL_CHECK_AIX_ALL_SOURCE();

            var found1, size_long = detect.sizeof("long") || return false;
            var found2, size_void = detect.sizeof("void*")|| return false;
            var x_LP64_long, x_LP32_long;
            if(size_long == 8 && size_void > 8) {
                x_LP64_long = "long";
            } else if(size_long == 4 && size_void > 4) {
                x_LP32_long = "long";
            }
            @curl_typeof_curl_off_t = "unknown";
            @curl_sizeof_curl_off_t = "unknown";
            @curl_format_curl_off_t = "unknown";
            @curl_format_curl_off_tu = "unknown";
            detect.line "Checking for 64-bit curl_off_t data type";
            if(@curl_typeof_curl_off_t == "unknown") {
                for(var _,type in [
                    x_LP64_long,
                    "int64_t",
                    "__int64",
                    "long long",
                    "longlong",
                    "__longlong_t"
                ]) {
                    var res = @DO_CURL_OFF_T_CHECK(checkType);
                    if(res) {
                        detect.success(@curl_typeof_curl_off_t);
                        break;
                    }
                }
            }
            detect.fail "None found!";
            detect.line "Checking for 32-bit curl_off_t data type";
            if(@curl_typeof_curl_off_t == "unknown") {
                for(var _,type in [
                    x_LP32_long,
                    "int32_t",
                    "__int32",
                    "int"
                ]) {
                    var res = @DO_CURL_CONFIGURE_CURL_OFF_T(checkType);
                    if(res) {
                        detect.success(@curl_typeof_curl_off_t);
                        break;
                    }
                }
            }
            if(@curl_typeof_curl_off_t == "unknown") {
                detect.abort "Cannot find data type for curl_off_t."
                return false;
            } else {
                detect.line "Checked for size of curl_off_t"
                detect.success(@CURL.curl_typeof_curl_off_t)
            }

            detect.line "Checking for formatting string directive for curl_off_t"
            var x_pull_headers;
            if(@curl_format_curl_off_t != "unknown") {
                x_pull_headers = true;
                var quickSed = function(val, sed) {
                    var spawned, exitCode, streams
                        = $("echo \"${val}\" | sed '${sed}'");
                    if(spawned && exitCode == 0) {
                        return streams[1].trim();
                    }
                }
                @curl_format_curl_off_t
                    = quickSed(@curl_format_curl_off_t, 's/[["]]//g');
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_t, 's/i$/u/');
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_tu, 's/d$/u/');
                @curl_format_curl_off_tu
                    = quickSed(@curl_format_curl_off_tu, 's/D$/U/');
            } else {
                x_pull_headers = false;
                switch(@curl_typeof_curl_off_t) {
                    case "long long":
                    case "__longlong":
                    case "__longlong_t":
                        @curl_format_curl_off_t = "lld";
                        @curl_format_curl_off_tu = "llu";
                    break;

                    case "long":
                        @curl_format_curl_off_t = "ld";
                        @curl_format_curl_off_tu = "lu";
                    break;

                    case "int":
                        @curl_format_curl_off_t = "d";
                        @curl_format_curl_off_tu = "u";
                    break;

                    case "__int64":
                        @curl_format_curl_off_t = "I64d";
                        @curl_format_curl_off_tu = "I64u";
                    break;

                    case "__int32":
                        @curl_format_curl_off_t = "I32d";
                        @curl_format_curl_off_tu = "I32u";
                    break;

                    case "__int16":
                        @curl_format_curl_off_t = "I16d";
                        @curl_format_curl_off_tu = "I16u";
                    break;

                    default:
                        detect.fail "cannot find print format string for curl_off_t."
                        return false;
                }
            }
            detect.success(@curl_format_curl_off_t);

            detect.line "Checking formatting string directive for unsigned curl_off_t"
            detect.success(@curl_format_curl_off_tu);

            // Getting suffix
            @curl_suffix_curl_off_t = "unknown";
            @curl_suffix_curl_off_tu = "unknown";
            @DO_CURL_OFF_T_SUFFIX_CHECK() || return false;

            if(x_pull_headers) {
                for(var def,hdr in {
                    CURL_PULL_SYS_TYPES_H:  "sys/types.h",
                    CURL_PULL_STDINT_H:     "sys/stdint.h",
                    CURL_PULL_INTTYPES_H:   "inttypes.h"
                }) detect.header("c", hdr) && detect.define(def);
            }

            // Now define curl_off_t!
            for(var def,val in {
                CURL_TYPEOF_CURL_OFF_T:     @curl_typeof_curl_off_t,
                CURL_FORMAT_CURL_OFF_T:     @curl_format_curl_off_t,
                CURL_FORMAT_CURL_OFF_TU:    @curl_format_curl_off_tu,
                CURL_FORMAT_OFF_T:          @curl_format_curl_off_t,
                CURL_SIZEOF_CURL_OFF_T:     @curl_sizeof_curl_off_t,
                CURL_SUFFIX_CURL_OFF_T:     @curl_suffix_curl_off_t,
                CURL_SUFFIX_CURL_OFF_TU:    @curl_suffix_curl_off_tu
            }) detect.define(def, val);
        },
        DO_CURL_OFF_T_CHECK: function(
            /* $1 */ checkType
        ) {
            if(@curl_typeof_curl_off_t == "unknown") {
                var tmp_includes = "";
                var tmp_source = "";
                var tmp_fmt = "";
                switch(checkType) {
                    case "int64_t":
                        tmp_includes =
                        tmp_source ="char f@<:@@:>@ = PRId64;"
                        tmp_fmt = "PRId64"
                    break;
                }
            }
        },
        DO_CURL_OFF_T_SUFFIX_CHECK: function() {
            detect.line "Checking for constant suffix string for curl_off_t";
            var tst_suffixes;
            switch(@curl_typeof_curl_off_t) {
                case "long long":
                case "__longlong":
                case "__longlong_t":
                    tst_suffixes = "LL::";
                break;

                case "long":
                    tst_suffixes = "L::";
                break;

                case "int":
                    tst_suffixes = "::";
                break;

                case "__int64":
                case "int64_t":
                    tst_suffixes = "LL:i64::";
                break;

                case "__int32":
                case "int32_t":
                    tst_suffixes = "L:i32::";
                break;

                case "__int16":
                case "int16_t":
                    tst_suffixes = "L:i16::";
                break;

                default:
                    throw "Expected datatype: ${@curl_typeof_curl_off_t}"
            }

            for(var n,tmp_ssuf in tst_suffixes.split("::")) {
                if(@curl_suffix_curl_off_t == "unknown") {
                    var tmp_usuf;
                    switch(tmp_ssuf) {
                        case "i64":
                        case "i32":
                        case "i16":
                            tmp_usuf = "u${tmp_ssuf}";
                        break;
                        case "L":
                        case "LL":
                            tmp_usuf = "U${tmp_ssuf}";
                        break;
                        default:
                            tmp_usuf = "";
                    }
                    var built, spawned, exitCode, streams
                        = detect.tryRun([
                            detect.getDefinesString(),
                            @curl_includes_inttypes_src,
                            "typedef ${@curl_typeof_curl_off_t} new_t",
                            "int main(int argc, char** argv){        ",
                            "   new_t s1;                            ",
                            "   new_t s2;                            ",
                            "   s1 = -10${tmp_ssuf};                 ",
                            "   s2 =  20${tmp_ssuf};                 ",
                            "   if(s1 > s2)                          ",
                            "       return 1;                        ",
                            "}"
                        ].join("\n"), "CC");
                    if(built && spawned) {
                        if(exitCode == 1) {
                            @curl_suffix_curl_off_t = tmp_ssuf;
                            @curl_suffix_curl_off_tu = tmp_usuf;
                            break;
                        }
                    } else {
                        detect.fail "Failed to execute test."
                        return false;
                    }
                }
            }
            if(@curl_suffix_curl_off_t == "unknown") {
                detect.fail "cannot find constant suffix string for curl_off_t."
            } else {
                detect.success(@curl_suffix_curl_off_t)
                detect.line "Checking for constant suffix string for unsigned curl_off_t"
                detect.success(@curl_suffix_curl_off_tu)
                return true;
            }
        },
        CURL_CHECK_NEED_REENTRANT_SYSTEM: function() {
            var host_os = detect.os();
            @tmp_need_reentrant = false;
            if(wildcard.match("solaris*", host_os)) {
                @tmp_need_reentrant = true;
            }
        },
        CURL_CHECK_NEED_REENTRANT_ERRNO: function() {
            var compiled = detect.tryCompile([
                detect.getDefinesString(),
                "#include <errno.h> ",
                "int main(){        ",
                "   if(0 != errno)  ",
                "       return 1;   ",
                "}                  "
            ].join("\n"), "C");
            if(compiled) {
                @tmp_errno = true;
            } else {
                @tmp_errno = false;
            }
            if(@tmp_errno) {
                compiled = detect.tryCompile([
                    detect.getDefinesString(),
                    "#include <errno.h>     ",
                    "#ifdef errno           ",
                    "   int dummy=1;        ",
                    "#else                  ",
                    "   Force compile error ",
                    "#endif                 ",
                    "int main(){ return 0; }"
                ].join("\n"), "C");
                if(compiled) {
                    @tmp_errno = "errno_macro_defined";
                    compiled = detect.tryCompile([
                        detect.getDefinesString(),
                        "#define _REENTRANT         ",
                        "#include <errno.h>         ",
                        "#ifdef errno               ",
                        "   int dummy=1;            ",
                        "#else                      ",
                        "   force compilation error ",
                        "#endif                     ",
                        "int main(){ return 0; }    "
                    ].join("\n"), "C");
                    if(compiled) {
                        @tmp_errno = "errno_macro_needs_reentrant";
                        @tmp_need_reentrant = true;
                    }
                }
            }
        },
        CURL_CHECK_NEED_REENTRANT_FUNCTIONS_R: function() {
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GMTIME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_LOCALTIME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_STRERROR_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_STRTOK_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_INET_NTOA_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETHOSTBYADDR_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETHOSTBYNAME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETPROTOBYNAME_R();
            }
            if(!@tmp_need_reentrant) {
                @CURL_CHECK_NEED_REENTRANT_GETSERVBYPORT_R();
            }
        },
        CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST: function(
            funct,      // Name of the function to look for.
            varName,    // Name of local variable to set function-specific knowledge to.
            generalVar, // Name of local variable to generally set to true.
            headers,    // List of headers to include.
        ) {
            var have_func = detect.func(funct);
            if(have_func) {
                var compiled = detect.tryCompile([
                    "#include <sys/types.h>     ",
                    "#include <time.h>          ",
                    "int main() {               ",
                    "   void* f;                ",
                    "   f = (void*)(${funct});  ",
                    "}                          "
                ]);
                if(compiled) {
                    this[varName] = "proto_declared";
                } else {
                    // I dont exactly understand AC_EGREP_CPP.
                    // So here is my take of testing if function is available,
                    // when _REENTRANT is defined.
                    var headerString = @{
                        var parts = [];
                        for(var n,hdr in headers) {
                            parts[] = "#include <${hdr}>";
                        }
                        return parts.join("\n");
                    };
                    var built, spawned, exitCode, streams
                        = detect.tryRun([
                            "#define _REENTRANT                 ",
                            headerString,
                            "int main(int argc, char** argv) {  ",
                            "   if((void*)(${funct}) != NULL) { ",
                            "       return 1;                   ",
                            "   }                               ",
                            "}                                  "
                        ].join("\n"), "C");
                    if(built) {
                        if(spawned && exitCode == 1) {
                            this[varName] = "proto_needs_reentrant";
                            this[generalVar] = true;
                        }
                    }
                }
            }
        },
        CURL_CHECK_NEED_REENTRANT_GMTIME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gmtime_r",
                "tmp_gmtime_r",
                "tmp_need_reentrant",
                ["sys/types.h", "time.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_LOCALTIME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "localtime_r",
                "tmp_localtime_r",
                "tmp_need_reentrant",
                ["sys/types.h", "time.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_STRERROR_R: function(){
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "strerror_r",
                "tmp_strerror_r",
                "tmp_need_reentrant",
                ["sys/types.h", "string.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_STRTOK_R: function(){
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "strtok_r",
                "tmp_strtok_r",
                "tmp_need_reentrant",
                ["sys/types.h", "string.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_INET_NTOA_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "inet_ntoa_r",
                "tmp_inet_ntoa_r",
                "tmp_need_reentrant",
                [
                    "sys/types.h",
                    "sys/socket.h",
                    "netinet/in.h",
                    "arpa/inet.h"
                ]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETHOSTBYADDR_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gethostbyaddr_r",
                "tmp_gethostbyaddr_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETHOSTBYNAME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "gethostbyname_r",
                "tmp_gethostbyname_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETPROTOBYNAME_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "getprotobyname_r",
                "tmp_getprotobyname_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CHECK_NEED_REENTRANT_GETSERVBYPORT_R: function() {
            @CURL_CHECK_NEED_REENTRANT_UNIVERSAL_TEST(
                "getservbyport_r",
                "tmp_getservbyport_r",
                "tmp_need_reentrant",
                ["sys/types.h", "netdb.h"]
            );
        },
        CURL_CONFIGURE_REENTRANT: function() {
            // Do a cache lookup
            var cacheKey = "need_reentrant";
            if(cacheKey in detect.cache) {
                var cacheVal = detect.cache.need_reentrant;
                detect.line "Checking if we use _REENTRANT";
                if(cacheVal == true || cacheVal == "true") {
                    detect.success "Yes."
                    return true;
                } else {
                    detect.fail "No."
                    return false;
                }
            }

            detect.line "Checking if _REENTRANT is already defined";
            @tmp_reentrant_initially_defined = null;
            @tmp_need_reentrant = null;
            var compiled = detect.tryCompile([
                detect.getDefinesString(),
                "#ifdef _REENTRANT              ",
                "      int dummy=1;             ",
                "#else                          ",
                "      force compilation error  ",
                "#endif                         ",
                "int main(){ return 0; }        "
            ].join("\n"), "C");
            if(compiled) {
                detect.success "Yes."
                @tmp_reentrant_initially_defined = true;
            } else {
                detect.fail "No."
                @tmp_reentrant_initially_defined = false;
            }

            if(!@tmp_reentrant_initially_defined) {
                detect.line "Checking if _REENTRANT is actually needed"
                @CURL_CHECK_NEED_REENTRANT_SYSTEM();
                if(!@tmp_need_reentrant) {
                    @CURL_CHECK_NEED_REENTRANT_ERRNO();
                }
                if(!@tmp_need_reentrant) {
                    @CURL_CHECK_NEED_REENTRANT_FUNCTIONS_R();
                }
                if(@tmp_need_reentrant) {
                    detect.success "Yes."
                    detect.cache[cacheKey] = true;
                    return true;
                } else {
                    detect.fail "No."
                    detect.cache[cacheKey] = false;
                    return false;
                }
            } else {
                detect.cache[cacheKey] = true;
            }

            detect.line "Checking if _REENTRANT is onwards defined";
            if(
                @tmp_reentrant_initially_defined
                || @tmp_need_reentrant
            ) {
                @CURL_CONFIGURE_FROM_NOW_ON_WITH_REENTRANT();
                detect.success "Yes."
                return true;
            } else {
                detect.fail "No."
                return false;
            }
        },
        CURL_CONFIGURE_FROM_NOW_ON_WITH_REENTRANT: function() {
            var cacheKey = "__reentrant_called";
            if(cacheKey in this) return;
            detect.defineUnquoted("NEED_REENTRANT", 1);
            detect.settings.preSource += [
                "#ifndef _REENTRANT     ",
                "#  define _REENTRANT   ",
                "#endif                 "
            ].join("\n");
            this[cacheKey] = true;
        },
        CURL_CHECK_AIX_ALL_SOURCE: function() {
            detect.line "Is this AIX we're building on?"
            if("IS_AIX" in detect.cache) {
                if(detect.cache.IS_AIX == "true" || detect.cache.IS_AIX == true) {
                    detect.success "Yes. (Cached)"
                    return true;
                } else {
                    detect.fail "Likely not. (Cached)";
                    return false;
                }
            }
            var built, spawned, exitCode, streams
                = detect.tryRun([
                    "int main(int argc, char** argv) {  ",
                    "   #ifdef _AIX                     ",
                    "       return 1;                   ",
                    "   #else                           ",
                    "       return 0;                   ",
                    "   #endif                          ",
                    "}                                  "
                ].join("\n"), "CC");
            if(built) {
                if(spawned && exitCode == 1) {
                    detect.success "Yes."
                    detect.define("_ALL_SOURCE");
                    detect.cache.IS_AIX = true;
                    return true;
                } else {
                    detect.fail "Likely not.";
                    detect.cache.IS_AIX = false;
                    return false;
                }
            }
        },
        CURL_INCLUDES_POLL: function() {
            @curl_includes_poll = [
                "/* includes start */       ",
                "#ifdef HAVE_SYS_TYPES_H    ",
                "#  include <sys/types.h>   ",
                "#endif                     ",
                "#ifdef HAVE_POLL_H         ",
                "#  include <poll.h>        ",
                "#endif                     ",
                "#ifdef HAVE_SYS_POLL_H     ",
                "#  include <sys/poll.h>    ",
                "#endif                     ",
                "/* includes end */         "
            ].join("\n");
            for(var n,hdr in [
                "sys/types.h",
                "poll.h",
                "sys/poll.h"
            ]) detect.header(hdr);
        },
        CURL_CONFIGURE_PULL_SYS_POLL: function() {
            @CURL_INCLUDES_POLL();
            @tst_poll_events_macro_defined = false;
            var compiled = detect.tryCompile([
                detect.settings.preSource,
                detect.getDefinesString(),
                @curl_includes_poll,
                "int main(int argv, char** argc) {          ",
                "   #if defined(events) || defined(revents) ",
                "       return 0;                           ",
                "   #else                                   ",
                "       force compilation error             ",
                "   #endif                                  ",
                "}                                          "
            ].join("\n"), "CC");
            @tst_poll_events_macro_defined = compiled;
            if(@tst_poll_events_macro_defined) {
                if(detect.header("sys/poll.h")) {
                    detect.defineUnquoted("CURL_PULL_SYS_POLL_H",1);
                }
            }
        },

        // QUOTE
        // This first checks if the preprocessor _THREAD_SAFE
        // symbol is already defined. If it isn't currently
        // defined a set of checks are performed to verify
        // if its definition is required. Finally, if
        // _THREAD_SAFE is already defined or needed it takes
        // care of making adjustments necessary to ensure
        // that it is defined equally for further configure
        // tests and generated config file.
        // /QUOTE
        CURL_CONFIGURE_THREAD_SAFE: function() {
            var cacheKey = "curl_thread_safe_checked";
            if(cacheKey in detect.cache) {
                detect.line "Checking for cURL thread safety"
                if(detect.cache[cacheKey] == "true") {
                    detect.success "Already checked. (Cached)"
                    return true;
                } else {
                    detect.fail "Already checked, failed. (Cached)"
                    return false;
                }
            }

            detect.line "Checking if _THREAD_SAFE is already defined"
            var rt;
            var compiled = detect.tryCompile([
                "int main(int argc, char** argv) {  ",
                "   #ifdef _THREAD_SAFE             ",
                "       int dummy=1;                ",
                "   #else                           ",
                "       force compilation error     ",
                "   #endif                          ",
                "}                                  "
            ].join("\n"), "CC");
            if(compiled) {
                detect.success "Yes."
                @tmp_thread_safe_initially_defined = true;
                detect.cache[cacheKey] = true;
                rt = true;
            } else {
                detect.fail "No."
                @tmp_thread_safe_initially_defined = false;
            }

            if(!@tmp_thread_safe_initially_defined) {
                detect.line "Checking if _THREAD_SAFE is actually needed"
                @CURL_CHECK_NEED_THREAD_SAFE_SYSTEM();
                if(@tmp_need_thread_safe) {
                    detect.success "Yes."
                    rt = true;
                } else {
                    detect.fail "No."
                }
            }

            detect.line "Checking if _THREAD_SAFE is onwards defined"
            if(
                @tmp_thread_safe_initially_defined
                || @tmp_need_thread_safe
            ) {
                @CURL_CONFIGURE_FROM_NOW_ON_WITH_THREAD_SAFE();
                detect.success "Yes.";
            } else {
                detect.fail "No.";
            }

            return rt;
        },
        CURL_CHECK_NEED_THREAD_SAFE_SYSTEM: function() {
            var host_os = detect.os();
            if( // QUOTE aix 4.2 and older /QUOTE
                wildcard.match("aix[123].*", host_os)
                || wildcard.match("aix4.[012].*", host_os)
            ) {
                @tmp_need_thread_safe = false;
            } else if(wildcard.match("aix*", host_os)) {
                // AIX 4.3 and newer
                @tmp_need_thread_safe = true;
            } else {
                @tmp_need_thread_safe = false;
            }
        },
        CURL_CONFIGURE_FROM_NOW_ON_WITH_THREAD_SAFE: function() {
            var cacheKey = "__thread_safe_called";
            if(cacheKey in this) return;
            detect.settings.preSource += [
                "#ifndef _THREAD_SAFE   ",
                "#  define _THREAD_SAFE ",
                "#endif                 "
            ].join("\n");
            this[cacheKey] = true;
        },

        // Compiler stuff.
        CURL_CHECK_COMPILER: function() {
            // Vars
            @compiler_id = "unknown";
            @compiler_num = 0;
            @flags_dbg_all = "unknown";
            @flags_dbg_yes = "unknown";
            @flags_dbg_off = "unknown";
            @flags_opt_all = "unknown";
            @flags_opt_yes = "unknown";
            @flags_opt_off = "unknown";
            @flags_prefer_cppflags = false;

            // Ok, seriously.
            // The chance of IceTea currently running on a platform
            // like HP-UX or such is TINY.
            // Hence, I'm gonna skip a bunch of checks here.
            // If you read this and have time to kill: Here is something you can do =)
            //
            // I just realized. I could copy some of these and use them for NativeCompiler instance!
            // Indeed, coding this is teaching me a lot as well.

            //@CURL_CHECK_COMPILER_DEC_C();
            //@CURL_CHECK_COMPILER_HPUX_C();
            //@CURL_CHECK_COMPILER_IBM_C();
            //@CURL_CHECK_COMPILER_INTEL_C();
            @CURL_CHECK_COMPILER_CLANG();
            @CURL_CHECK_COMPILER_GNU_C();
            //@CURL_CHECK_COMPILER_LCC();
            //@CURL_CHECK_COMPILER_SGI_MIPSPRO_C();
            //@CURL_CHECK_COMPILER_SGI_MIPS_C();
            //@CURL_CHECK_COMPILER_SUNPRO_C();
            //@CURL_CHECK_COMPILER_TINY_C();
            //@CURL_CHECK_COMPILER_WATCOM_C();

            if(@compiler_id == "unknown") {
                print([
                    // QUOTE
                    "***                                                                        ",
                    "*** Warning: This configure script does not have information about the     ",
                    "*** compiler you are using, relative to the flags required to enable or    ",
                    "*** disable generation of debug info, optimization options or warnings.    ",
                    "***                                                                        ",
                    "*** Whatever settings are present in CFLAGS will be used for this run.     ",
                    "***                                                                        ",
                    "*** If you wish to help the cURL project to better support your compiler   ",
                    "*** you can report this and the required info on the libcurl development   ",
                    "*** mailing list: https://cool.haxx.se/mailman/listinfo/curl-library/      ",
                    "***                                                                        ",
                    // /QUOTE
                    "*** PLEASE NOTE: The above text came from the original Autotools based     ",
                    "*** build process. IceTea WILL behave differently. In case of an issue that",
                    "*** you think is related to IceTea, please raise an issue on Github at     ",
                    "*** https://github.com/IngwiePhoenix/IceTea instead!                       ",
                    "*** cURL is not related to IceTea and vice versa. I just built this script ",
                    "*** for my own purpose. But making it better and offering it as an         ",
                    "*** alternative way of building libcURL, might be awesome! :)              ",
                    "***                                                                        "
                ].join("\n"));
            }
        },
        CURL_CHECK_COMPILER_GNU_C: function() {
            detect.line "Checking if compiler is GNU C\n";
            if(detect.macro("__GNUC__") && @compiler_id == "unknown") {
                print detect.out;
                detect.success "GNU C Compiler found."
                @compiler_id = "GNU_C";
                var gccver, gccvhi, gccvlo;
                var invoke = function(args) {
                    var spawned, exitCode, streams
                        = $("${@detect.toolCache.CC} ${args}");
                    if(spawned && exitCode == 0) {
                        return streams[1].trim();
                    } else {
                        return false;
                    }
                }
                gccver = invoke("-dumpversion");
                gccvhi = gccver.split(".")[0];
                gccvlo = gccver.split(".")[1];
                @compiler_num = (
                    ( toNumber(gccvhi) * 100 )
                    + toNumber(gccvlo)
                );
                @flags_dbg_all = [
                    "-g", "-g0", "-g1", "-g2", "-g3",
                    "-ggdb", "-gstabs", "-gstabs+",
                    "-gcoff", "-gxcoff", "-gdwarf-2",
                    "-gvms"
                ].join(" ");
                @flags_dbg_yes = "-g";
                @flags_dbg_off = "";
                @flags_opt_all = "-O -O0 -O1 -O2 -O3 -Os";
                @flags_opt_yes = "-O2";
                @flags_opt_off = "-O0";
            } else {
                print detect.out;
                detect.fail "GNU C Compiler not found."
            }
        },
        CURL_CHECK_COMPILER_CLANG: function() {
            @CURL_CHECK_COMPILER_GNU_C();
            detect.line "Checking if compiler is clang\n"
            if(detect.macro("__clang__")) {
                print detect.out
                detect.success "Clang found.";
                var invoke = function(args) {
                    var spawned, exitCode, streams
                        = $("${@detect.toolCache.CC} ${args}");
                    if(spawned && exitCode == 0) {
                        return streams[1].trim();
                    } else {
                        return false;
                    }
                }
                var clangver, clangvhi, clangvlo;
                @compiler_id = "CLANG"
                clangver = invoke("-dumpversion")
                clangvhi = clangver.split(".")[0];
                clangvlo = clangver.split(".")[1];
                @compiler_num = (
                    ( toNumber(clangvhi) * 100 )
                    + toNumber(clangvlo)
                );
                @flags_dbg_all = [
                    "-g", "-g0", "-g1", "-g2", "-g3",
                    "-ggdb", "-gstabs", "-gstabs+",
                    "-gcoff", "-gxcoff", "-gdwarf-2",
                    "-gvms"
                ].join(" ");
                @flags_dbg_yes="-g"
                @flags_dbg_off=""
                @flags_opt_all="-O -O0 -O1 -O2 -Os -O3 -O4"
                @flags_opt_yes="-Os"
                @flags_opt_off="-O0"
            }
        },
        CURL_SET_COMPILER_BASIC_OPTS: function() {
            if(@compiler_id != "unknown") {
                if(@compiler_id == "GNU_C" || @compiler_id == "CLANG") {
                    @CURL_CONVERT_INCLUDE_TO_ISYSTEM();
                }
                var tmp_cflags = [];
                var tmp_cppflags = [];
                switch(@compiler_id) {
                    case "CLANG":
                        // QUOTE
                        // Disable warnings for unused arguments, otherwise clang will
                        // warn about compile-time arguments used during link-time, like
                        // -O and -g and -pedantic.
                        // /QUOTE
                        tmp_cflags[] = "-Qunused-arguments";
                    break;
                    case "GNU_C":
                        // QUOTE: Select strict ANSI C compiler mode
                        tmp_cflags[] = "-std1"
                        // QUOTE: Turn off optimizer ANSI C aliasing rules
                        tmp_cflags[] = "-noansi_alias"
                        // QUOTE: Generate warnings for missing function prototypes
                        tmp_cflags[] = "-warnprotos"
                        // QUOTE: Change some warnings into fatal errors
                        tmp_cflags[] = "-msg_fatal toofewargs,toomanyargs"
                    break;
                    // Skipping HPUX, INTEL, WATCOM, ...
                }

                detect.line "Checking if compiler accepts some basic options"
                var flags = [] + tmp_cppflags + tmp_cflags;
                if(detect.tryCompilerFlag(flags, "CC")) {
                    detect.success "Working. Added: ${flags.join(' ')}"
                    // Since we are one level too deep, we need to hack into it.
                    // FIXME: target() configurable should also just return a function when no body is given.
                    IceTea.__targets.curl.settings.CC.flags += flags;
                    return true;
                } else {
                    detect.fail "No. Options rejected: ${flags}"
                    return false;
                }
            }
        },
        CURL_TEST_COMPILER_OPTIONS: function(cacheKey, flags, verb) {
            flags = __.isArray(flags)? flags : [flags];
            if(cacheKey in this) { return this[cacheKey]; }
            detect.line "Checking if compiler accepts ${verb} options...\n";
            if(detect.tryCompilerFlag(flags, "CC")) {
                print detect.out;
                detect.success "compiler options added: ${flags}";
                IceTea.__targets.curl.settings.CC.flags += flags;
                this[cacheKey] = true;
            } else {
                print detect.out;
                detect.fail "Rejected: ${@flags_dbg_yes}"
                this[cacheKey] = false;
            }
        },
        CURL_SET_COMPILER_DEBUG_OPTS: function() {
            if(@compiler_id != "undefined") {
                if(@CURL_DEBUG) {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_debug_on_flags",
                        @flags_dbg_yes,
                        "debug enabling"
                    );
                } else {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_debug_off_flags",
                        @flags_dbg_off,
                        "debug disabling"
                    );
                }
            }
        },
        CURL_SET_COMPILER_OPTIMIZE_OPTS: function() {
            if(@compiler_id != "unknown") {
                // TODO: Honour the assume_yes/assume_no things.
                // This would enable us to actually derive settings off
                // the assumptions that the beginning of configure() had made.
                // For now, we just accept a TRUE or FALSE to the table :)
                if(@CURL_OPTIMIZE) {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_optimize_on_flags",
                        @flags_opt_yes,
                        "optimization enabling"
                    );
                } else {
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_optimize_off_flags",
                        @flags_opt_off,
                        "optimization disabling"
                    );
                }
            }
        },
        CURL_SET_COMPILER_WARNING_OPTS: function() {
            // FIXME: Use IceTea's warnings, instead.
            // In fact, we should possibly make this an API: detect.warning(...)
            // Would allow for the Compiler objects to actually be used for testing.
            // Therefore: FIXME: Better CompilerObject integration!
            if(@compiler_id != "unknown") {
                var cflags = [];
                var cppflags = [];
                switch(@compiler_id) {
                    case "CLANG":
                        cflags = [
                            "-pedantic",
                            "-Wall",
                            "-Wextra",
                            "-Wpointer-arith",
                            "-Wwrite-strings",
                            "-Wshadow",
                            "-Winline",
                            "-Wnested-externs",
                            "-Wmissing-declarations",
                            "-Wmissing-prototypes",
                            "-Wno-long-long",
                            "-Wfloat-equal",
                            "-Wno-multichar",
                            "-Wsign-compare",
                            "-Wundef",
                            "-Wno-format-nonliteral",
                            "-Wendif-labels",
                            "-Wstrict-prototypes",
                            "-Wdeclaration-after-statement",
                            "-Wcast-align",
                            "-Wno-system-headers",
                            "-Wshorten-64-to-32"
                        ];
                        if(@compiler_num > 101) {
                            // Clang 1.1 or higher. So, that's what compiler_num is for.
                            cflags[] = "-Wunused";
                        }
                    break;

                    case "GNU_C":
                        // TODO: cross-compile check. I doubt IceTea actually does XC yet...at least not very good.
                        if(@compiler_num > 300) {
                            cflags[] = "-pedantic";
                        }
                        cflags += ["-Wall","-W"];
                        if(@compiler_num > 104) {
                            cflags += ["-Wpointer-arith","-Wwrite-strings"];
                            // TODO: Cross-compile check.
                            if(@compiler_num > 300) {
                                cflags += ["-Wunused","-Wshadow"];
                            }
                        }
                        if(@compiler_num > 207) {
                            cflags += ["-Winline","-Wnested-externs"];
                            if(@compiler_num > 300) {
                                cflags[] = "-Wmissing-declarations";
                                cflags[] = "-Wmissing-prototypes";
                            }
                        }
                        if(@compiler_num > 295) {
                            cflags[] = "-Wno-long-long";
                        }
                        if(@compiler_num > 296) {
                            cflags += [
                                "-Wfloat-equal",
                                "-Wno-multichar",
                                "-Wsign-compare",
                                "-Wundef"
                            ];
                        }
                        if(@compiler_num > 297) {
                            cflags[] = "-Wno-format-nonliteral";
                        }
                        if(@compiler_num > 300) {
                            // I encountered a tiny GCC rent. Heh :)
                        }
                        if(@compiler_num > 303) {
                            cflags += ["-Wendif-labels","-Wstrict-prototypes"];
                        }
                        if(@compiler_num > 304) {
                            cflags[] = "-Wdeclaration-after-statement";
                        }
                        if(@compiler_num > 400) {
                            cflags[] = "-Wstrict-aliasing=3";
                        }
                        if(@compiler_num > 402) {
                            cflags[] = "-Wcast-align";
                        }
                        if(@compiler_num > 403) {
                            cflags += [
                                "-Wtype-limits",
                                "-Wold-style-declaration",
                                "-Wmissing-parameter-type",
                                "-Wempty-body",
                                "-Wclobbered",
                                "-Wignored-qualifiers",
                                "-Wconversion",
                                "-Wno-sign-conversion",
                                "-Wvla"
                            ];
                        }
                        if(@compiler_num > 405) {
                            if(detect.macro("__WIN32")) {
                                cflags[] = "-Wno-pedantic-ms-format";
                            }
                        }
                        // No warnings on isystem headers
                        if(@compiler_num > 300) {
                            cflags[] = "-Wno-system-headers";
                        } else {
                            // TODO: Cross-Compile stuff
                        }
                    break;
                }
                if(#cflags > 0 || #cppflags > 0) {
                    detect.line "Checking if compiler accepts options\n";
                    var flags = [] cflags + cppflags;
                    return @CURL_TEST_COMPILER_OPTIONS(
                        "__checked_warnings_flags",
                        flags,
                        "strict warning"
                    );
                }
            }
        },
        CURL_CHECK_COMPILER_HALT_ON_ERROR: function() {
            // TODO: Make a call-guard, damnit. :I
            // I.e.: Abuse __get@...() to auto-guard calls.
            var cacheKey = "__called_halt_on_error";
            if(cacheKey in this) return this[cacheKey];

            //detect.line "Checking if compiler halts on compilation errors";
            // Ok seriously. How do I implement this? Big, fat, TODO.
        },
        CURL_CHECK_COMPILER_ARRAY_SIZE_NEGATIVE: function() {
            // QUOTE
            // Verifies if the compiler actually halts after the
            // compilation phase without generating any object
            // code file, when the source code tries to define a
            // type for a constant array with negative dimension.
            // /QUOTE

            // Callguard.
            var cacheKey = "__array_size_negative";
            if(cacheKey in this) return true; // Only possible solution. else exit()s immediately.

            detect.line "Checking if compiler halts on negative sized arrays"
            var src = [
                "typedef char bad_t[sizeof(char) == sizeof(int) ? -1 : -1 ];",
                "int main() {",
                "   bad_t dummy;",
                "}"
            ].join("\n");
            if(! detect.tryCompile(src, "CC")) {
                detect.success "Yes (hopefuly?)"
                this[cacheKey] = true;
                return true;
            } else {
                detect.fail "I guess no."
                detect.abort "compiler does not halt on negative sized arrays."
                return false;
            }
        },
        CURL_CHECK_COMPILER_PROTOTYPE_MISMATCH: function() {
            var cacheKey = "__proto_mismatch_called";
            if(cacheKey in this) return true;
            detect.line "Checking if compiler halts on function prototype mismatch"
            var src = [
                "#include <stdlib.h>    ",
                "int rand(int n);       ",
                "int rand(int n) {      ",
                "   if(n)               ",
                "       return ++n;     ",
                "   else                ",
                "       return n;       ",
                "}                      ",
                "int main() {           ",
                "   int i[2]={0,0};     ",
                "   int j = rand(i[0]); ",
                "   if(j) return j;     ",
                "}                      "
            ].join("\n");
            if(! detect.tryCompile(src, "CC")) {
                detect.success "Yes."
                this[cacheKey] = true;
                return true;
            } else {
                detect.fail "No."
                detect.abort "compiler does not halt on function prototype mismatch."
                return false;
            }
        },
        CURL_CHECK_COMPILER_SYMBOL_HIDING: function() {
            var cacheName = "__symbol_hiding_called";
            if(cacheName in this) return this[cacheName];
            detect.line "Checking if compiler supports hiding library internal symbols"
            var supports_symbol_hiding = false;
            var symbol_hiding_CFLAGS = "";
            var symbol_hiding_EXTERN = "";
            var tmp_CFLAGS = "";
            var tmp_EXTERN = "";
            switch(@compiler_id) {
                case "CLANG":
                    // Easy. Use -fvisibility=...
                    tmp_EXTERN ="__attribute__ ((__visibility__ (\"default\")))";
                    tmp_CFLAGS = "-fvisibility=hidden";
                    supports_symbol_hiding = true;
                break;
                case "GNU_C":
                    if(@compiler_num > 304) {
                        var spawned, exitCode, streams
                            = $("${detect.toolCache.CC} --help --verbose");
                        var out;
                        if(exitCode == 0) {
                            if(#streams[1] > #streams[2]) {
                                out = streams[1];
                            } else {
                                out = streams[2];
                            }
                        } else {
                            detect.abort "The program exited with non-zero exit code: ${exitCode}"
                            return false;
                        }
                        if(out.indexOf("-fvisibility=") != -1) {
                            tmp_EXTERN = "__attribute__ ((__visibility__ (\"default\")))";
                            tmp_CFLAGS = "-fvisibility=hidden";
                            supports_symbol_hiding = true;
                        }
                    }
                break;
                // Skipping other compilers...
            }
            if(supports_symbol_hiding) {
                var src = [
                    "${tmp_extern} char *dummy(char *buff); ",
                    "char *dummy(char *buff) {              ",
                    "   if(buff)                            ",
                    "       return ++buff;                  ",
                    "   else                                ",
                    "       return buff;                    ",
                    "}                                      ",
                    "int main(ing argc, char** argv) {      ",
                    "   char b[16];                         ",
                    "   char *r = dummy(&b[0]);             ",
                    "   if(r) return (int)*r;               ",
                    "}                                      "
                ].join("\n");
                if(detect.tryCompile(src, "CC", tmp_CFLAGS)) {
                    supports_symbol_hiding = true;
                } else {
                    supports_symbol_hiding = false;
                }
            }
            if(supports_symbol_hiding) {
                detect.success "Yes."
                this[cacheKey] = true;
                return true;
            } else {
                detect.success "No."
                this[cacheKey] = false;
                return false;
            }
        },
        CURL_CHECK_CURLDEBUG: function() {
            // TODO: This function, right here.
            //var cacheKey = "__called_curldebug";
            //if(cacheKey in this) return this[cacheKey];
            var supports_curldebug = "unknown";
            if(@CURL_CURLDEBUG) {
                // Skip shared build checks...
                // Skip static build check...
            }
            // Skipped some test I didn't even understand...
            // detect.line "Checking if curl debug memory tracking can be enabled";
            if(@CURL_CURLDEBUG) {
                IceTea.__targets.curl.settings.CC.defines[] = "CURLDEBUG";
            }
            if(@CURL_DEBUG) {
                IceTea.__targets.curl.settings.CC.defines[] = "DEBUGBUILD";
            }
        },
        CURL_CHECK_FUNC_CLOCK_GETTIME_MONOTONIC: function() {
            var cacheKey = "__monotronic_gettime_func_called";
            if(cacheKey in this) return this[cacheKey];

            for(var x,hdr in [
                "sys/types.h",
                "sys/time.h",
                "time.h"
            ]) detect.header(hdr);

            detect.line "Checking for monotonic clock_gettime";
            if(@CURL_RT == false) {
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "   struct timespec ts;     ",
                    "   (void)clock_gettime(    ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   );                      ",
                    "}                          "
                ].join("\n"), "CC")) {
                    detect.success "Yes"
                    @ac_cv_func_clock_gettime = true;
                    this[cacheKey] = true;
                } else {
                    detect.fail "No"
                    @ac_cv_func_clock_gettime = false;
                    this[cacheKey] = false;
                }
            }
        },
        CURL_CHECK_LIBS_CLOCK_GETTIME_MONOTONIC: function() {
            @CURL_CHECK_FUNC_CLOCK_GETTIME_MONOTONIC();
            var cacheKey = "__monotronic_gettime_libs_called";
            if(cacheKey in this) return this[cacheKey];

            detect.line "Checking for clock_gettime in libraries"
            var curl_cv_gclk_LIBS = false;
            for(var n,x_xlibs in ['','-lrt','-lposix4']) {
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "    struct timespec ts;    ",
                    "    (void)clock_gettime(   ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   );                      ",
                    "}                          "
                ].join("\n"), "CC")) {
                    curl_cv_gclk_LIBS = x_xlibs;
                    break;
                }
            }
            if(curl_cv_gclk_LIBS == false) {
                detect.fail "cannot find clock_gettime"
                detect.warn "HAVE_CLOCK_GETTIME_MONOTONIC will not be defined"
                @ac_cv_func_clock_gettime = false;
                this[cacheKey] = false;
                return false;
            } else if(curl_cv_gclk_LIBS == "") {
                detect.success "no additional lib required"
                @ac_cv_func_clock_gettime = true;
            } else {
                @settings.LINK.libraries[]
                    = curl_cv_gclk_LIBS.sub(2);
                detect.success curl_cv_gclk_LIBS;
                @ac_cv_func_clock_gettime = true;
            }
            // Skipping cross-compile check...
            if(@ac_cv_func_clock_gettime) {
                detect.line "Checking if monotonic clock_gettime works"
                if(detect.tryCompile([
                    detect.getDefinesString(),
                    "#ifdef HAVE_STDLIB_H       ",
                    "#include <stdlib.h>        ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TYPES_H    ",
                    "#include <sys/types.h>     ",
                    "#endif                     ",
                    "#ifdef HAVE_SYS_TIME_H     ",
                    "#include <sys/time.h>      ",
                    "#ifdef TIME_WITH_SYS_TIME  ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#else                      ",
                    "#ifdef HAVE_TIME_H         ",
                    "#include <time.h>          ",
                    "#endif                     ",
                    "#endif                     ",
                    "int main() {               ",
                    "   struct timespec ts;     ",
                    "   if (0 == clock_gettime( ",
                    "       CLOCK_MONOTONIC,    ",
                    "       &ts                 ",
                    "   ))                      ",
                    "       exit(0);            ",
                    "    else                   ",
                    "       exit(1);            ",
                    "}                          "
                ].join("\n"), "CC")) {
                    detect.success "Yes";
                    this[cacheKey] = true;
                } else {
                    detect.fail "No";
                    detect.warn "HAVE_CLOCK_GETTIME_MONOTONIC will not be defined"
                    @ac_cv_func_clock_gettime = false;
                    this[cacheKey] = false;
                }
                if(@ac_cv_func_clock_gettime) {
                    detect.define("HAVE_CLOCK_GETTIME_MONOTONIC", 1);
                }
                return this[cacheKey];
            }
        }
    },
    init: function() {
        cli.group "cURL library";
        // [En|Dis]able
        var eda = function(name, desc) {
            detect.enable("curl-${name}", "Enable cURL ${desc}");
            detect.disable("curl-${name}", "Disable cURL ${desc}");
        }
        for(var name, desc in {
            // Debug
            debug:          "debug options",
            // Optimization
            optimize:       "optimization options",
            // Warnings
            warnings:       "warnings",
            werror:         "to treat all warnings as errors",
            // curldebug. Im guessing it's the debugging infra
            // within cURL itself. (extra logging, etc)
            curldebug:      "internal debug functionalities",
            // Symbol hiding
            "hide-symbols": "library to hide it's internal symbols",
            // C-Ares support?
            // FIXME: c-ares for IceTea. PhoenixEngine has it, move it in.
            // Use the + operator and IceTea.hasTarget - for instance.
            cares:          "to use c-ares for DNS lookups",
            // librt
            rt:             "dependance on librt",
        }) eda(name, desc);
        // Libraries.
        // Once again: Scripting languages are hella powerful.
        for(var _,lib in @CURL.sslLibs) {
            detect.with(
                "curl-${lib}",
                "SSL: Support ${lib} in cURL"
            );
        }
        for(var _,lib in @CURL.windowsLibs) {
            detect.with(
                "curl-${lib}",
                "Windows: Support ${lib} in cURL"
            );
        }
        for(var _,lib in @CURL.otherLibs) {
            detect.with(
                "curl-${lib}",
                "Enable building cURL with ${lib}"
            );
        }
        for(var _,word in @CURL.genericEnables) {
            detect.enable("curl-${word}", "Enable: ${word}")
        }

        // Autoconf-like
        autoconf.AC_SYS_LARGEFILE_INIT();
    },
    configure: function() {
        // Save current pre-source.
        var __PRE_SOURCE = detect.settings.preSource;

        // FIXME's:
        // - include/curl/curlbuild.h.in : Make an IceTea variant.

        // Almost like a try-catch, but simpler.
        // We sandbox execution so that we can
        // reset the preSource properly and do any neccessary
        // pre/post manipulation without corrupting it.
        // Just in case.
        var ConfigureReturn = @{
            // # Check options
            // FIXME: I could probably simplify this by a lot. Thats for later tho.
            // ## Debug
            @CURL.CURL_DEBUG = null;
            if(detect.enabled("curl-debug") && !detect.disabled("curl-debug")) {
                @CURL.CURL_DEBUG = true;
            } else if(!detect.enabled("curl-debug") && detect.disabled("curl-debug")) {
                @CURL.CURL_DEBUG = false;
            } else {
                @CURL.CURL_DEBUG = false;
            }
            // ## Optimization
            @CURL.CURL_OPTIMIZE = null;
            if(detect.enabled("curl-optimize") && !detect.disabled("curl-optimize")) {
                @CURL.CURL_OPTIMIZE = true;
            } else if(!detect.enabled("curl-optimize") && detect.disabled("curl-optimize")) {
                @CURL.CURL_OPTIMIZE = false;
            } else {
                // QUOTE
                // configure's optimize option not specified. Initially we will
                // handle this as a a request contrary to configure's setting
                // for --enable-debug. IOW, initially, for debug-enabled builds
                // this will be handled as a request to disable optimizations if
                // possible, and for debug-disabled builds this will be handled
                // initially as a request to enable optimizations if possible.
                // Finally, if the compiler is known and CFLAGS and CPPFLAGS do
                // not have any optimizer flag the request will be honored, in
                // any other case the request can not be honored.
                // IOW, existing optimizer flags defined in CFLAGS or CPPFLAGS
                // will always take precedence over any initial assumption.
                // /QUOTE
                @CURL.CURL_OPTIMIZE = (@CURL.CURL_DEBUG == true ? false : true);
            }
            // ## Warnings
            @CURL.CURL_WARNINGS = null;
            if(detect.enabled("curl-warnings") && !detect.disabled("curl-warnings")) {
                @CURL.CURL_WARNINGS = true;
            } else if(!detect.enabled("curl-warnings") && detect.disabled("curl-warnings")) {
                @CURL.CURL_WARNINGS = false;
            } else {
                @CURL.CURL_WARNINGS = @CURL.CURL_DEBUG;
            }
            // ## -Werror
            @CURL.CURL_WERROR = null;
            if(detect.enabled("curl-werror")) {
                @settings.native.allErrors = true;
                @CURL.CURL_WERROR = true;
            } else {
                @CURL.CURL_WERROR = false;
            }
            // ## CurlDebug
            @CURL.CURL_CURLDEBUG = null;
            if(detect.enabled("curl-curldebug") && !detect.disabled("curl-curldebug")) {
                @CURL.CURL_CURLDEBUG = true;
            } else if(!detect.enabled("curl-curldebug") && detect.disabled("curl-curldebug")) {
                @CURL.CURL_CURLDEBUG = false;
            } else {
                @CURL.CURL_CURLDEBUG = @CURL.CURL_DEBUG;
            }
            // ## Symbol hiding
            @CURL.CURL_HIDE_SYMBOLS = null;
            if(detect.enabled("curl-hide-symbols") && !detect.disabled("curl-hide-symbols")) {
                @CURL.CURL_HIDE_SYMBOLS = true;
            } else if(!detect.enabled("curl-hide-symbols") && detect.disabled("curl-hide-symbols")) {
                @CURL.CURL_HIDE_SYMBOLS = false;
            } else {
                @CURL.CURL_HIDE_SYMBOLS = true;
            }
            // ## C-Ares
            @CURL.CURL_CARES = null;
            // FIXME: IceTea support, custom path/prefix?
            if(detect.enabled("curl-cares") && !detect.disabled("curl-cares")) {
                @CURL.CURL_CARES = true;
                if(detect.lib("cares")) {
                    @settings.LINK.libraries[] = "cares";
                } else if(detect.lib("c-ares")) {
                    @settings.LINK.libraries[] = "c-ares";
                }
            } else if(!detect.enabled("curl-cares") && detect.disabled("curl-cares")) {
                @CURL.CURL_CARES = false;
            } else {
                @CURL.CURL_CARES = false;
            }
            // ## (lib)rt
            // I know, they do a reverse check.
            // But...no. Not now, later.
            @CURL.CURL_NO_RT = null;
            if(detect.disabled("curl-rt")) {
                @CURL.CURL_NO_RT = true;
            }

            // # Path separator check.
            // Im going to go the easyway out.
            @CURL.CURL_PATHSEP = sys.pathSep;

            // # Storing the configure options.
            // ... actually, not possible with IceTea. Good to know.
            @CURL.CURL_CONFIGURE_OPTIONS = "\"\"";
            detect.define("CONFIGURE_OPTIONS", CURL_CONFIGURE_OPTIONS);

            // # Tools
            var CURL_TOOLS = {
                GREP: "grep",
                SED: "sed",
                EGREP: "egrep",
                // Hm. These tools could be problematic on other platforms.
                // So, ill just comment them out for now.
                //AR: "ar"
            }
            for(var define,tool in CURL_TOOLS) {
                var toolValue = detect.tool(tool);
                if(toolValue == "") {
                    detect.abort "${tool} is highly required!";
                    return false;
                }
                detect.define(define, toolValue);
            }

            // # curlbuild.h
            // Remove an existing one, if it exists.
            var curlbuild_h = pfs.join(CURL_SOURCEDIR, "include/curl/curlbuild.h")
            if(pfs.isFile(curlbuild_h)) {
                pfs.delete(curlbuild_h);
            } else if(pfs.isDir(curlbuild_h)) {
                debug.abort "What have you done? \"${curlbuild_h}\" is a folder..."
                return false;
            }

            // # cURL version.
            // If I had a regex parser, this would've actually been easier.
            // So for now Ill rely on the UNIX method,
            // but I'll have to find a regex lib if I want to self-contain this build!
            @CURL.CURL_VERSION = null;
            @CURL.CURL_VERSION_NUM = null;
            ;{
                var spawned, exitCode, streams
                    = $("sed -ne 's/^#define LIBCURL_VERSION \"\(.*\)\"/\1/p' ${CURL_SOURCEDIR}/include/curl/curlver.h");
                if(spawned && exitCode == 0) {
                    @CURL.CURL_VERSION = streams[0].trim();
                    detect.define("CURLVERSION", @CURL.CURL_VERSION);
                }
            }
            ;{
                var spawned, exitCode, streams
                    = $("sed -ne 's/^#define LIBCURL_VERSION_NUM 0x\(.*\)/\1/p' ${srcdir}/include/curl/curlver.h");
                if(spawned && exitCode == 0) {
                    @CURL.CURL_VERSION_NUM = streams[0].trim();
                    detect.define("VERSIONNUM", @CURL.CURL_VERSION_NUM);
                }
            }

            // # Compiler
            detect.findCompiler("CC");

            // # Get canonical host...
            // Port: AC_CANONICAL_HOST ( cpu-maschine-OS )

            // # curl_off_t
            // QUOTE
            // Our curl_off_t internal and external configure settings
            // /QUOTE
            @CURL.CURL_CONFIGURE_CURL_OFF_T();

            // # AIX All-source
            // QUOTE
            // This defines _ALL_SOURCE for AIX
            // /QUOTE
            @CURL.CURL_CHECK_AIX_ALL_SOURCE();

            // QUOTE
            // Our configure and build reentrant settings
            // /QUOTE
            @CURL.CURL_CONFIGURE_THREAD_SAFE() || return false;
            @CURL.CURL_CONFIGURE_REENTRANT() || return false;

            // QUOTE: check for how to do large files
            autoconf.AC_SYS_LARGEFILE() || return false;

            // Normally, we'd encounter libtool specific calls here.
            // We skip them, end of story. :)
            // Thing is, it is mentioned that libcurl might need different flags,
            // depending on being build shared or not.
            // Look, IceTea sees this target as static - its marked "lib".
            // Here is where it gets interesting. If I was to define a shared library
            // target, I would have to undergo similar configuration. However,
            // instead I would simply use shared library flags.
            // So for now libcurl will build staticaly, and staticaly only,
            // under IceTea. When I implemented proper support for shlibs,
            // and found a smart way to maintain state between the two
            // so that I can mimimize re-run overhead, I will implement
            // support for a shared libcurl.

            // # Compiler checks
            @CURL.CURL_CHECK_COMPILER() || return false;
            @CURL.CURL_SET_COMPILER_BASIC_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_DEBUG_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_OPTIMIZE_OPTS() || return false;
            @CURL.CURL_SET_COMPILER_WARNING_OPTS() || return false;

            // Skipping Intel UNIX C Check...

            @CURL.CURL_CHECK_COMPILER_HALT_ON_ERROR() || return false;
            @CURL.CURL_CHECK_COMPILER_ARRAY_SIZE_NEGATIVE() || return false;
            @CURL.CURL_CHECK_COMPILER_PROTOTYPE_MISMATCH() || return false;
            @CURL.CURL_CHECK_COMPILER_SYMBOL_HIDING() || return false;

            // Skipping Automake stuff

            @CURL.CURL_CHECK_CURLDEBUG() || return false;

            // And officially, the hard part IS. DONE.
            // According to cURL, we're now doing dependency checks and
            // other configuration. But the pardest part, which is
            // setting up the build environment, is obviously done.
            // ...
            // Phew. From hereon out, i might actually inline ports, instead
            // of attaching them to the CURL object.

            // Skipping Unittest configuration...
            // Skipping cross-compiling stuff...
            // Skipping IRIX checks...
            // Skipping AIX checks...

            detect.line "Checking for windows.h"
            if(detect.tryCompile([
                "#undef inline                                  ", // <- Huh?
                "#ifndef WIN32_LEAN_AND_MEAN                    ",
                "#define WIN32_LEAN_AND_MEAN                    ",
                "#endif                                         ",
                "#include <windows.h>                           ",
                "int main() {                                   ",
                "#if defined(__CYGWIN__) || defined(__CEGCC__)  ",
                "   HAVE_WINDOWS_H shall not be defined.        ",
                "#else                                          ",
                "   int dummy=2*WINVER;                         ",
                "#endif                                         ",
                "}                                              "
            ].join("\n"), "CC")) {
                // On Cygwin, we can't rely on windows.h
                @CURL.ac_cv_header_windows_h = true;
                detect.success "Found."
                detect.defineUnquoted("HAVE_WINDOWS_H", 1);
                detect.defineUnquoted("WIN32_LEAN_AND_MEAN");
            } else {
                @CURL.ac_cv_header_windows_h = false;
                detect.fail "No."
            }

            detect.line "Checking whether build target is a native Windows one";
            if(! @CURL.ac_cv_header_windows_h) {
                detect.fail "No."
            } else {
                if(detect.tryCompile([
                    "int main(int argc, char** argv) {                              ",
                    "#if defined(__MINGW32__) || defined(__MINGW32CE__) || \\       ",
                    "   (defined(_MSC_VER) && (defined(_WIN32) || defined(_WIN64))) ",
                    "   int dummy=1;                                                ",
                    "#else                                                          ",
                    "   Not a native Windows build target.                          ",
                    "#endif                                                         ",
                    "}                                                              "
                ].join("\n"), "CC")) {
                    @CURL.ac_cv_native_windows = true;
                    detect.success "Yes."
                } else {
                    @CURL.ac_cv_native_windows = false;
                    detect.fail "No."
                }
            }

            if(@CURL.ac_cv_native_windows) {
                // TBD:
                // CURL_CHECK_HEADER_WINSOCK
                // CURL_CHECK_HEADER_WINSOCK2
                // CURL_CHECK_HEADER_WS2TCPIP
                // CURL_CHECK_HEADER_WINLDAP
                // CURL_CHECK_HEADER_WINBER
            } else {
                // Mass-define all the false's
                for(var k,v in {
                    ac_cv_header_winsock_h:     false,
                    ac_cv_header_winsock2_h:    false,
                    ac_cv_header_ws2tcpip_h:    false,
                    ac_cv_header_winldap_h:     false,
                    ac_cv_header_winber_h:      false
                }) { @CURL[k] = v; }
            }

            // Skipping: CURL_CHECK_WIN32_LARGEFILE

            var support = function(name, cb, def) {
                def = def || true;
                detect.info "Checking whether to support ${name}"
                if(detect.enabled(name) && !detect.disabled(name)) {
                    detect.success "Yes."
                    return cb(true);
                } else if(!detect.enabled(name) && detect.disabled(name)) {
                    detect.fail "No."
                    return cb(true);
                } else {
                    return cb(def); // ALWAYS assume the positive default, if none given.
                }
            }
            support("http", {|bool|
                if(!bool) {
                    detect.warn "disable HTTP disables FTP over proxy and RTSP"
                    detect.define("CURL_DISABLE_HTTP", 1);
                    detect.define("CURL_DISABLE_RTSP", 1);
                }
            });
            support("ftp", {|b| !b && detect.define("CURL_DISABLE_FTP",1)});
            support("file", {|b| !b && detect.define("CURL_DISABLE_FILE", 1)});
            support("ldap", {|b| !b && detect.define("CURL_DISABLE_LDAP", 1)});
            support("ldaps", {|b|
                if(b == false) detect.define("CURL_DISABLE_LDAPS", 1);
                else if(b == true) {
                    if("CURL_DISABLE_LDAP" in detect.cache) {
                        detect.warn "LDAP needs to be enabled to support LDAPS"
                        detect.define("CURL_DISABLE_LDAPS", 1);
                    }
                } else {
                    if(!("CURL_DISABLE_LDAP" in detect.cache)) {
                        detect.fail "No."
                        detect.define("CURL_DISABLE_LDAPS", 1);
                    } else {
                        detect.success "Yes."
                        detect.define("HAVE_LDAP_SSL", 1);
                    }
                }
            }, "guess");
            support("rtsp", {|b|
                if(!b) detect.define("CURL_DISABLE_RTSP", 1);
                else if(b) {
                    if("CURL_DISABLE_HTTP" in detect.cache) {
                        detect.abort "HTTP support needs to be enabled in order to enable RTSP support!"
                        return false;
                    } else {
                        @CURL.curl_rtsp_msg = true;
                    }
                } else {
                    if("CURL_DISABLE_HTTP" in detect.cache) {
                        detect.fail "No."
                    } else {
                        detect.success "Yes."
                        @CURL.curl_rtsp_msg = true;
                    }
                }
                return true;
            }.bind(this)) || return false;
            support("proxy", {|b| !b && detect.define("CURL_DISABLE_PROXY", 1)});
            support("dict", {|b| !b && detect.define("CURL_DISABLE_DICT", 1)});
            support("telnet", {|b| !b && detect.define("CURL_DISABLE_TELNET", 1)});
            support("tftp", {|b| !b && detect.define("CURL_DISABLE_TFTP", 1)});
            support("pop3", {|b| !b && detect.define("CURL_DISABLE_POP3", 1)});
            support("imap", {|b| !b && detect.define("CURL_DISABLE_IMAP", 1)});
            support("smb", {|b| !b && detect.define("CURL_DISABLE_SMB", 1)});
            support("smtp", {|b| !b && detect.define("CURL_DISABLE_SMTP", 1)});
            support("gopher", {|b| !b && detect.define("CURL_DISABLE_GOPHER", 1)});

            // Skipping built-in manual...

            support("libcurl_option", function(that){
                if(!that) { // Then this.
                    detect.define("CURL_DISABLE_LIBCURL_OPTION", 1);
                    @CURL.curl_libcurl_msg = false;
                }
            }.bind(this));
            support("libgcc", {|b|
                if(b) {
                    if(detect.lib("gcc")) {
                        @settings.LINK.libraries[] = "gcc";
                        return true;
                    } else {
                        detect.abort "Can not link with libgcc!"
                        return false;
                    }
                }
            }.bind(this));

            // Port: CURL_CHECK_LIB_XNET
            detect.line "Checking if X/Open network library is required"
            @CURL.tst_lib_xnet_required = false;
            if(detect.tryCompile([
                "int main (void) {                                                      ",
                "#if defined(__hpux) && defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 600)",
                "  return 0;                                                            ",
                "#elif defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)               ",
                "  return 0;                                                            ",
                "#else                                                                  ",
                "  force compilation error                                              ",
                "#endif                                                                 ",
                "}                                                                      "
            ].join("\n"), "CC")) {
                detect.success "Yes."
                @CURL.tst_lib_xnet_required = true;
                @settings.LINK.libraries[] = "xnet";
            } else {
                detect.fail "No."
            }

            if(detect.func("gethostbyname")) {
                // By default, IceTea already macro's that one for us.
                // So, it's a noop now.
            } else {
                // Check if we have to use the nsl lib?
                if(detect.libfunc("nsl", "gethostbyname")) {
                    @settings.LINK.libraries[] = "nsl";
                }
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                if(detect.libfunc("socket", "gethostbyname")) {
                    @settings.LINK.libraries[] = "socket";
                } else if(detect.libfunc("watt", "gethostbyname")) {
                    @settings.LINK.libraries[] = "watt";
                    @settings.CC.includeDirs[] = "/dev/env/WATT_ROOT/inc";
                    @settings.LINK.libraryDirs[] = "/dev/env/WATT_ROOT/lib";
                } else {
                    // So, appearently there is one weird target that requires
                    // socket+nsl to let you use gethostbyname
                    // ... Damn.
                    detect.line "Checking for gethostbyname with both nsl and socket libs"
                    if(detect.tryCompile([
                        "int main(){        ",
                        "   gethostbyname();",
                        "   return 0;       ",
                        "}                  "
                    ].join("\n"), "CC", [
                        "-lnsl", "-lsocket"
                    ])) {
                        detect.success "Yes."
                        detect.define("HAVE_GETHOSTBYNAME", 1);
                        @settings.LINK.libraries += ["nsl", "socket"];
                    } else {
                        detect.fail "No."
                    }
                }
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                // For windows systems
                // Skipping windows-related checks...
                // Skipping Minix checks...
                // Skipping eCos checks...
                // Skipping Haiku OS checks...
                // Skipping BeOS checks...
            }
            if(!("HAVE_GETHOSTBYNAME" in detect.cache)) {
                detect.abort "couldn't find libraries for gethostbyname()"
                return false;
            }

            if(detect.func("strcasecmp")) {
                // noop
            } else if(detect.libfunc("resolve", "strcasecmp")) {
                @settings.LINK.libraries[] = "resolve";
            }

            // Port: CURL_CHECK_LIBS_CONNECT
            detect.line "Checking for connect in libraries"
            var tst_connect_need_LIBS = false;
            for(var n,flags in [
                [],         // None
                ["-lsocket"]// libsocket
            ]) {
                if(detect.tryCompile([
                    //@CURL.curl_includes_winsock2,
                    "#ifndef HAVE_WINDOWS_H             ",
                    "   int connect(int, void*, int);   ",
                    "#endif                             ",
                    "int main() {                       ",
                    "   if(0 != connect(0, 0, 0))       ",
                    "       return 1;                   ",
                    "}                                  "
                ].join("\n"), "CC", flags)) {
                    tst_connect_need_LIBS = flags;
                    break;
                }
            }
            if(tst_connect_need_LIBS != false) {
                for(var n,flag in tst_connect_need_LIBS) {
                    // Strip the "-l":
                    @settings.LINK.libraries[] = flag.sub(2);
                }
            } else {
                detect.fail "cannot find connect"
                detect.abort "cannot find connect function in libraries."
                return false;
            }

            @CURL.CURL_CHECK_LIBS_CLOCK_GETTIME_MONOTONIC();

            // Ok. So normally cURL would do some zlib testing now.
            // But I will first go and edit an API. Using IceTea,
            // we could also embed zlib. Sooo... instead, I'll also
            // test, if the target exists.
            var isWith,value = detect.isWith("zlib");
            var zFound = null;
            if(isWith) {
                @{ // Hack: Using a function, we can use return as a cheap short-circuit method!
                    if(value != "") {
                        if(wildcard.match("internal:*", value)) {
                            // Requested a reachable zlib through IceTea...
                            var tName = value.split(":")[1];
                            detect.line "Checking for IceTea-reachable zlib: ${tName}"
                            if(IceTea.hasTarget(tName)) {
                                detect.success "Found"
                                @needs[] = tName;
                                return;
                            } else {
                                detect.fail "Not found. Continuing search."
                            }
                        }
                        // Back up the current settings...
                        // We create a new array to hold the backup,
                        // since the + operator modifies the this of the array.
                        detect.line "Searching for libz includes in: ${value}"
                        var includeDir = pfs.join(value, "include");
                        if(!pfs.isDir(includeDir)) {
                            detect.fail "Not found."
                        } else {
                            detect.success "Found: ${includeDir}"
                            detect.line "Searching for libz libraries in: ${value}\n"
                            for(var n,dirname in ["lib", "lib32", "lib64"]) {
                                var libPath = pfs.join(value, dirname);
                                if(pfs.isDir(libPath)) {
                                    var list = pfs.glob(libPath, "libz.*");
                                    if(#list) {
                                        // Even on windows, it has the "lib" prefix.
                                        // Therefore, we can cheat, and just omit the extension
                                        // instead.
                                        for(var n,libfile in list) {
                                            if(detect.libfunc(libfile, "inflateEnd")) {
                                                @settings.LINK.libraries[] = libfile;
                                                @settings.native.includeDirs[] = includeDir;
                                                print detect.out;
                                                detect.success "Found: ${libfile}"
                                                return;
                                            }
                                        }
                                    } else continue;
                                } else continue;
                            }
                        }
                    } else {
                        // Search the usual way.
                        if(detect.header("zlib.h") && detect.libfunc("z", "inflateEnd")) {
                            // Well, since IceTea defines stuff already,
                            // and since only both can pass, it's pretty straight forward.
                            // We do: nothing.
                            @curl_zlib_msg = "enabled"
                            return;
                        }
                    }
                };
            }


        };

        // Done.
        detect.settings.preSource = __PRE_SOURCE;

        return ConfigureReturn;
    },
    settings: {
        native: {
            includeDirs: [pfs.join(
                dep.get("curl"),
                "include"
            )]
        },
        CC: {
            flags: [],
            includeDirs: [],
            defines: []
        },
        LINK: {
            libraries: [],
            libraryDirs: []
        }
    },
    exports: {
        native: {
            includeDirs: [pfs.join(
                dep.get("curl"),
                "include"
            )]
        }
    }
}
