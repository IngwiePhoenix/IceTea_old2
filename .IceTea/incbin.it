target("incbin", "exe") {
    input: ["deps/incbin/incbin.c"],
    exports: {
        native: {
            includeDirs: ["deps/incbin"]
        }
    }
}

/**
 * This rule allows for IncBin to be utilized in a programatic way.
 *
 * It can get _any_ file as input and is hence a raw rule.
 *
 * After the incbin tool is built, a pseudo-header containing INCBIN() statements is generated,
 * mapping the key and value in the input object to valid statements.
 *
 * The compiled incbin file is then added to the parent target.
 *
 * Example:
 * 		MyApp : Application
 * 			| src/main.c
 * 			| src/script_engine.c
 *
 * This is a typical target. Now, we could also make a second target:
 * 		MyApp_Scripts : IncBin
 * 			| lib/script.js
 *
 * The input definition for that target would look like so:
 *
 * target("MyApp_Scripts", "incbin") {
 * 	   input: {
 * 	       script: "lib/script.js"
 * 	   }
 * }
 *
 * You realize: Normally, you supply arrays as input. But this is a special rule - the input specified goes to this target directly.
 * That means, that it also can specify a new input format.
 *
 * This rule would then do the following:
 *
 * 		1. Build a temporary file in out/ - for instance "MyApp_Scripts.incbin.h"
 * 		2. Once the incbin tool is compiled: out/icnbin out/MyApp_Scripts.incbin.h -o @out (where @out is the result of estimate)
 * 		3. Once built, the file is processed through steps and then attached as a regular input to the requesting target's output.
 *
 * To make sure that both, the .h and .c file are avilable, they're forced in:
 * - MyApp_Scripts.incbin.h : We add -include to the target's native.flags settings.
 * - MyApp_Scripts.incbin.c : Process this file into steps, and add it to the final rule as dep and input.
 */
rule("incbin", "Include Binary") {
    pattern: "%o/%t.incbin.c",
    options: {
        raw: true
    },
    configure: function() {
        return true;
    },
    // FIXME: Maybe we can put this into configure instead?
    modify: function(target){
        // Verify that the target has the proper options.
        if(!("for" in target)) {
            throw "${target.name} must specify 'for'!"
        }
        if(!__.isString(target.for)) {
            throw "${target.name} may only specify a string in 'for'."
        }

        // Store a reference.
        var forTarget = IceTea.__targets[target.for];
        target.__forTarget = forTarget;
    },
    build: function() {
        // FIXME: Nicer version of that.
        var incbinTarget = IceTea.__targets.incbin;
        // FIXME: IceTea.Target.estimate()
        var incbinPath = incbinTarget.rule.estimate(incbinTarget);
        var baseFile = pfs.join(
            __outputdir,
            "${@target.name}.incbin"
        );
        var headerFile = "${baseFile}.h";
        var sourceFile = "${baseFile}.c";

        var header = [
            '/* Generated by IceTea */',
            '#include "incbin.h"'
        ];

        var headerContents = []
        for(var symbol,file in @in) {
            headerContents[] = "INCBIN(${symbol}, \"${file}\");";
        }
        var headerStr = headerContents.join("\n");

        // Generate a proper headerguard.
        var hash = sha2.string(headerStr);
        var defineKey = "__INCBIN_ICETEA__${hash}_H";
        header[] = "#ifndef ${defineKey}";
        header[] = "#define ${defineKey}";
        header[] = headerStr;
        header[] = "#endif // ${defineKey}";

        // Write.
        //print "" // FIXME: Global IceTea display settings. Possibly reporters??
        detect.line "Writing: ${headerFile}..."
        var bytes = File.writeWhole(header.join("\n"), headerFile);
        if(__.isNull(bytes)) {
            detect.fail "Unable to write."
            return false;
        } else {
            detect.success "${bytes} bytes written."
        }

        // Now spin up the sub-build for IncBin itself.
        // It will be ran immediately.
        var sub, tasks = IceTea.SubRunner(incbinTarget);
        if(sub) {
            // Build was successful!
            var incbinIncludes = @{
                var list = [];
                if(
                    "INCBIN" in @target.settings
                    && "includeDirs" in @target.settings.INCBIN
                ) {
                    for(var i,inc in @target.settings.INCBIN.includeDirs) {
                        list[] = "-I${inc}"
                    }
                }
                return list.join(" ");
            };
            var cmd = "${incbinPath} -o ${sourceFile} ${headerFile}";
            detect.info "$ ${cmd}";
            var spawned, exitCode, output = $(cmd);
            if(#output[1]>0) echo output[1];
            if(#output[2]>0) echo output[2];
            if(spawned) {
                if(exitCode == 0) {
                    detect.info "Generated incbin header!"
                    // Good. We now have a .c file.
                    // We need to make it an object.
                    // Easiest way: Tell IceTea to do so! :)
                    // FIXME: This can be automated, I am very sure...
                    var step = IceTea.findStepForFile(sourceFile);
                    var objectFile = step.estimate({name: @target.name}, sourceFile);
                    var compiler = detect.activeCompilerMap.CC;
                    var cmd = compiler.buildCommand(
                        sourceFile, objectFile,
                        [__outputdir] + incbinTarget.exports.native.includeDirs,
                        [], [],
                        [], null, [],
                        false, false
                    );
                    pfs.mkdir(pfs.dirname(objectFile));
                    detect.info "$ ${cmd}"

                    // Run the compiler command.
                    var spawned, exitCode, output
                        = $(cmd);

                    if(#output[1]>0) echo output[1];
                    if(#output[2]>0) echo output[2];
                    detect.line "The build was"
                    if(spawned && exitCode == 0) {
                        detect.success "Successful!"
                        // Attach new dependencies.
                        var forTarget = @target.__forTarget;
                        var finalRule = forTarget.__finalTask;
                        finalRule.in.push(objectFile);
                        return true;
                    } else {
                        detect.fail "A failure. Exit status: ${exitCode}"
                        return false;
                    }
                } else {
                    // Build failed.
                    debug "Generator failed."
                    return false;
                }
            } else {
                debug "Process not launched (${exitCode})."
                return false;
            }
        } else {
            // SubBuild failed.
            debug "Sub-Build failed."
            return false;
        }
    },
    clean: function() {
        var baseFile = path.join(
            __outputdir,
            "${@target.name}.incbin"
        );
        var headerFile = "${baseFile}.h";
        var sourceFile = "${baseFile}.c";

        return
            pfs.delete(headerFile)
            && pfs.delete(sourceFile);
    },
    _present: function() {
        var forTarget = @target.__forTarget;
        return forTarget.title || forTarget.name;
    }
}
